{% comment %} /snippets/bundle-delivery-info.liquid - Bundle delivery information display and logic {% endcomment %}

<script type="application/json" id="bundle-delivery-info">
  {
    "isBundle": {% if product.metafields.bundleinfo.bundleproducts.value %}true{% else %}false{% endif %},
    "bundleOptions": {{ product.options | json }},
    "componentDeliveryData": [
      {% for component in product.metafields.bundleinfo.bundleproducts.value %}
        {% assign full_product = all_products[component.handle] %}
        {
          "product": {
            "id": {{ full_product.id }},
            "title": "{{ full_product.title | escape }}",
            "handle": "{{ full_product.handle }}",
            "delivery_time": "{{ full_product.metafields.delivery.delivery_time | escape }}",
            "estimated_date": "{{ full_product.metafields.delivery.estimated_date | escape }}"
          },
          "variants": [
            {% assign valid_variants = false %}
            {% for variant in full_product.variants %}
              {% if valid_variants %},{% endif %}
              {% assign valid_variants = true %}
              {% assign variant_delivery_date = variant.metafields.delivery.delivery_estimated_date %}
              {% unless variant_delivery_date %}
                {% assign variant_delivery_date = variant.metafields.delivery.delivery_estimated_date.value %}
              {% endunless %}
              {
                "id": {{ variant.id }},
                "title": "{{ variant.title | escape }}",
                "delivery_estimated_date": "{{ variant_delivery_date | escape }}",
                "delivery_time": "{{ variant.metafields.delivery.delivery_time | escape }}",
                "estimated_date": "{{ variant.metafields.delivery.estimated_date | escape }}"
              }
            {% endfor %}
          ]
        }{% unless forloop.last %},{% endunless %}
      {% endfor %}
    ],
    "bundleDeliveryData": {
      "bundleProduct": {
        "delivery_time": "{{ product.metafields.delivery.delivery_time | escape }}",
        "estimated_date": "{{ product.metafields.delivery.estimated_date | escape }}"
      },
      "bundleVariant": {
        {% assign bundle_variant_delivery_date = product.selected_or_first_available_variant.metafields.delivery.delivery_estimated_date %}
        {% unless bundle_variant_delivery_date %}
          {% assign bundle_variant_delivery_date = product.selected_or_first_available_variant.metafields.delivery.delivery_estimated_date.value %}
        {% endunless %}
        "delivery_estimated_date": "{{ bundle_variant_delivery_date | escape }}",
        "delivery_time": "{{ product.selected_or_first_available_variant.metafields.delivery.delivery_time | escape }}",
        "estimated_date": "{{ product.selected_or_first_available_variant.metafields.delivery.estimated_date | escape }}"
      }
    }
  }
</script>

<script>
document.addEventListener("DOMContentLoaded", () => {
  console.log("üöÄ BUNDLE DELIVERY DEBUG - Starting initialization");
  
  // Get bundle delivery data
  const bundleDeliveryElement = document.getElementById("bundle-delivery-info");
  //console.log("üì¶ Bundle delivery element found:", bundleDeliveryElement);
  
  if (!bundleDeliveryElement) {
    //console.error("‚ùå Bundle delivery element not found!");
    return;
  }

  let bundleInfo;
  try {
    bundleInfo = JSON.parse(bundleDeliveryElement.textContent);
    console.log("‚úÖ Bundle info parsed successfully:", bundleInfo);
  } catch (error) {
    //console.error("‚ùå Error parsing bundle delivery info:", error);
    //console.log("Raw JSON content:", bundleDeliveryElement.textContent);
    return;
  }

  //console.log("üîç Is bundle?", bundleInfo.isBundle);
  if (!bundleInfo.isBundle) {
    //console.log("‚è≠Ô∏è Not a bundle product, exiting");
    return;
  }
  
  //console.log("üìä Bundle options:", bundleInfo.bundleOptions);
  //console.log("üß© Component delivery data:", bundleInfo.componentDeliveryData);
  //console.log("üì¶ Bundle delivery data:", bundleInfo.bundleDeliveryData);
  
  // Debug: Show what components are available for matching
  //console.log("\nüéØ AVAILABLE COMPONENTS FOR MATCHING:");
  bundleInfo.componentDeliveryData.forEach((component, index) => {
    //console.log(`   ${index + 1}. "${component.product.title}" (handle: ${component.product.handle})`);
  });
  
  //console.log("\nüéØ BUNDLE OPTIONS TO MATCH:");
  bundleInfo.bundleOptions.forEach((option, index) => {
    //console.log(`   ${index + 1}. "${option}"`);
  });

  // Improved fuzzy matching function with penalty scoring
  function calculateMatchScore(optionName, productData) {
    const optionWords = optionName.toLowerCase().split(/[\s\/]+/);
    const titleWords = productData.product.title.toLowerCase().split(/[\s\/]+/);
    const handleWords = productData.product.handle.toLowerCase().split(/[\-\_]+/);
    
    let score = 0;
    let penaltyScore = 0;
    
    //console.log(`üîç Analyzing "${optionName}" vs "${productData.product.title}"`);
    //console.log(`   Option words: [${optionWords.join(', ')}]`);
    //console.log(`   Title words: [${titleWords.join(', ')}]`);
    
    // POSITIVE SCORING: Check title matches
    optionWords.forEach(optionWord => {
      titleWords.forEach(titleWord => {
        if (optionWord === titleWord) {
          score += 10; // Exact match
          //console.log(`   ‚úÖ Exact match: "${optionWord}" = +10`);
        } else if (titleWord.includes(optionWord) || optionWord.includes(titleWord)) {
          score += 5; // Partial match
          //console.log(`   ‚úÖ Partial match: "${optionWord}" ~ "${titleWord}" = +5`);
        }
      });
    });
    
    // POSITIVE SCORING: Check handle matches  
    optionWords.forEach(optionWord => {
      handleWords.forEach(handleWord => {
        if (optionWord === handleWord) {
          score += 8; // Exact match
          //console.log(`   ‚úÖ Handle exact: "${optionWord}" = +8`);
        } else if (handleWord.includes(optionWord) || optionWord.includes(handleWord)) {
          score += 3; // Partial match
          //console.log(`   ‚úÖ Handle partial: "${optionWord}" ~ "${handleWord}" = +3`);
        }
      });
    });
    
    // NEGATIVE SCORING: Penalize misleading matches
    // If looking for "cover" but title contains "seat" but not "cover" = penalty
    if (optionWords.includes('cover') && !titleWords.includes('cover') && titleWords.includes('seat')) {
      penaltyScore += 20;
      //console.log(`   ‚ùå Cover/Seat mismatch penalty = -20`);
    }
    
    // If looking for "base" but title contains "seat" but not "base" = penalty
    if (optionWords.includes('base') && !titleWords.includes('base') && titleWords.includes('seat')) {
      penaltyScore += 20;
      //console.log(`   ‚ùå Base/Seat mismatch penalty = -20`);
    }
    
    // If looking for specific product type but title has different type = penalty
    if (optionWords.includes('holder') && !titleWords.includes('holder')) {
      penaltyScore += 15;
      //console.log(`   ‚ùå Holder mismatch penalty = -15`);
    }
    
    const finalScore = Math.max(0, score - penaltyScore);
    //console.log(`   üéØ Final score: ${score} - ${penaltyScore} = ${finalScore}`);
    
    return finalScore;
  }

  // Apply 4-level hierarchy
  function getDeliveryInfo(matchingVariant, componentData, bundleInfo) {
    //console.log("üîç DELIVERY HIERARCHY - Starting hierarchy check");
    //console.log("üì¶ Matching variant:", matchingVariant);
    //console.log("üß© Component data:", componentData);
    
    // Level 1: Component variant metafields (strongest)
    //console.log("ü•á Level 1 - Component variant metafields:");
    //console.log("   delivery_estimated_date:", matchingVariant?.delivery_estimated_date);
    //console.log("   delivery_time:", matchingVariant?.delivery_time);
    //console.log("   estimated_date:", matchingVariant?.estimated_date);
    
    if (matchingVariant && matchingVariant.delivery_estimated_date) {
      //console.log("‚úÖ Found at Level 1: delivery_estimated_date =", matchingVariant.delivery_estimated_date);
      return { type: 'estimated_date', value: matchingVariant.delivery_estimated_date, source: 'component_variant' };
    }
    if (matchingVariant && matchingVariant.delivery_time) {
      //console.log("‚úÖ Found at Level 1: delivery_time =", matchingVariant.delivery_time);
      return { type: 'delivery_time', value: matchingVariant.delivery_time, source: 'component_variant' };
    }
    if (matchingVariant && matchingVariant.estimated_date) {
      //console.log("‚úÖ Found at Level 1: estimated_date =", matchingVariant.estimated_date);
      return { type: 'estimated_date', value: matchingVariant.estimated_date, source: 'component_variant' };
    }
    
    // Level 2: Component product metafields
    //console.log("ü•à Level 2 - Component product metafields:");
    //console.log("   delivery_time:", componentData.product.delivery_time);
    //console.log("   estimated_date:", componentData.product.estimated_date);
    
    if (componentData.product.delivery_time) {
      //console.log("‚úÖ Found at Level 2: delivery_time =", componentData.product.delivery_time);
      return { type: 'delivery_time', value: componentData.product.delivery_time, source: 'component_product' };
    }
    if (componentData.product.estimated_date) {
      //console.log("‚úÖ Found at Level 2: estimated_date =", componentData.product.estimated_date);
      return { type: 'estimated_date', value: componentData.product.estimated_date, source: 'component_product' };
    }
    
    // Level 3: Bundle variant metafields
    //console.log("ü•â Level 3 - Bundle variant metafields:");
    //console.log("   delivery_estimated_date:", bundleInfo.bundleDeliveryData.bundleVariant.delivery_estimated_date);
    //console.log("   delivery_time:", bundleInfo.bundleDeliveryData.bundleVariant.delivery_time);
    //console.log("   estimated_date:", bundleInfo.bundleDeliveryData.bundleVariant.estimated_date);
    
    if (bundleInfo.bundleDeliveryData.bundleVariant.delivery_estimated_date) {
      //console.log("‚úÖ Found at Level 3: delivery_estimated_date =", bundleInfo.bundleDeliveryData.bundleVariant.delivery_estimated_date);
      return { type: 'estimated_date', value: bundleInfo.bundleDeliveryData.bundleVariant.delivery_estimated_date, source: 'bundle_variant' };
    }
    if (bundleInfo.bundleDeliveryData.bundleVariant.delivery_time) {
      //console.log("‚úÖ Found at Level 3: delivery_time =", bundleInfo.bundleDeliveryData.bundleVariant.delivery_time);
      return { type: 'delivery_time', value: bundleInfo.bundleDeliveryData.bundleVariant.delivery_time, source: 'bundle_variant' };
    }
    if (bundleInfo.bundleDeliveryData.bundleVariant.estimated_date) {
      //console.log("‚úÖ Found at Level 3: estimated_date =", bundleInfo.bundleDeliveryData.bundleVariant.estimated_date);
      return { type: 'estimated_date', value: bundleInfo.bundleDeliveryData.bundleVariant.estimated_date, source: 'bundle_variant' };
    }
    
    // Level 4: Bundle product metafields (weakest)
    //console.log("üèÖ Level 4 - Bundle product metafields:");
    //console.log("   delivery_time:", bundleInfo.bundleDeliveryData.bundleProduct.delivery_time);
    //console.log("   estimated_date:", bundleInfo.bundleDeliveryData.bundleProduct.estimated_date);
    
    if (bundleInfo.bundleDeliveryData.bundleProduct.delivery_time) {
      //console.log("‚úÖ Found at Level 4: delivery_time =", bundleInfo.bundleDeliveryData.bundleProduct.delivery_time);
      return { type: 'delivery_time', value: bundleInfo.bundleDeliveryData.bundleProduct.delivery_time, source: 'bundle_product' };
    }
    if (bundleInfo.bundleDeliveryData.bundleProduct.estimated_date) {
      //console.log("‚úÖ Found at Level 4: estimated_date =", bundleInfo.bundleDeliveryData.bundleProduct.estimated_date);
      return { type: 'estimated_date', value: bundleInfo.bundleDeliveryData.bundleProduct.estimated_date, source: 'bundle_product' };
    }
    
    //console.log("‚ùå No delivery info found at any level");
    return { type: 'none', value: 'No delivery info', source: 'none' };
  }

  // Update bundle delivery display and hidden inputs
  function updateBundleDelivery() {
    //console.log("üîÑ UPDATE BUNDLE DELIVERY - Starting update");
    
    const variantInput = document.querySelector('.product__main__content input[name="id"]');
    //console.log("üéØ Variant input found:", variantInput);
    //console.log("üéØ Variant input value:", variantInput?.value);
    
    if (!variantInput) {
      //console.error("‚ùå Variant input not found!");
      return;
    }

    const variantId = parseInt(variantInput.value, 10);
    //console.log("üÜî Variant ID:", variantId);
    
    //console.log("üåç Window productData:", window.productData);
    const bundleVariant = window.productData?.variants?.find(v => v.id === variantId);
    //console.log("üéØ Bundle variant found:", bundleVariant);
    
    if (!bundleVariant) {
      //console.error("‚ùå Bundle variant not found!");
      return;
    }

    const currentSelection = bundleVariant.options || [];
    //console.log("üéÆ Current selection:", currentSelection);

    // Do fuzzy matching for each bundle option
    const deliveryResults = [];
    //console.log("üßÆ Starting fuzzy matching...");
    
    bundleInfo.bundleOptions.forEach((optionName, index) => {
      //console.log(`\n--- üéØ Processing option ${index + 1}: ${optionName} ---`);
      
      let bestMatch = null;
      let bestScore = 0;
      
      // Find best component match
      bundleInfo.componentDeliveryData.forEach(component => {
        const score = calculateMatchScore(optionName, component);
        //console.log(`üßÆ Score for "${optionName}" vs "${component.product.title}": ${score}`);
        if (score > bestScore) {
          bestScore = score;
          bestMatch = component;
        }
      });
      
      //console.log(`üèÜ Best match for "${optionName}": ${bestMatch?.product.title} (score: ${bestScore})`);
      
      if (bestMatch) {
        const selectedValue = currentSelection[index];
        //console.log(`üéÆ Selected value: "${selectedValue}"`);
        //console.log(`üéØ Available variants:`, bestMatch.variants.map(v => v.title));
        
        // Find matching variant
        const matchingVariant = bestMatch.variants.find(variant => 
          variant.title === selectedValue || 
          variant.title.includes(selectedValue) || 
          selectedValue.includes(variant.title)
        );
        //console.log(`‚úÖ Matching variant found:`, matchingVariant);
        
        // Get delivery info using hierarchy
        const deliveryInfo = getDeliveryInfo(matchingVariant, bestMatch, bundleInfo);
        //console.log(`üéØ Delivery info result:`, deliveryInfo);
        
        if (deliveryInfo.type !== 'none') {
          deliveryResults.push({
            productTitle: bestMatch.product.title,
            deliveryValue: deliveryInfo.value,
            deliveryType: deliveryInfo.type,
            source: deliveryInfo.source
          });
          //console.log(`‚úÖ Added to results: ${bestMatch.product.title}: ${deliveryInfo.value}`);
        } else {
          //console.log(`‚ùå No delivery info found for ${bestMatch.product.title}`);
        }
      } else {
        //console.log(`‚ùå No component match found for "${optionName}"`);
      }
    });

    //console.log("\nüéØ FINAL RESULTS:", deliveryResults);
    //console.log("üìù Total delivery results found:", deliveryResults.length);

    // Update frontend display
    const deliveryContainer = document.querySelector('.delivery-info p');
    //console.log("üé® Delivery container found:", deliveryContainer);
    
    if (deliveryContainer) {
      if (deliveryResults.length > 0) {
        // Check if all products have the same delivery info
        const uniqueDeliveryValues = [...new Set(deliveryResults.map(result => result.deliveryValue))];
        //console.log("üîç Unique delivery values:", uniqueDeliveryValues);
        
        let deliveryHTML;
        if (uniqueDeliveryValues.length === 1) {
          // All products have same delivery info - show unified message
          deliveryHTML = `
            <strong>ESTIMATED DELIVERY:</strong><br>
            <strong>All products:</strong> ${uniqueDeliveryValues[0]}
          `;
          //console.log("‚úÖ All products have same delivery info, showing unified message");
        } else {
          // Different delivery info - show individual lines
          deliveryHTML = `
            <strong>ESTIMATED DELIVERY:</strong><br>
            ${deliveryResults.map(result => 
              `‚Ä¢ <strong>${result.productTitle}:</strong> ${result.deliveryValue}`
            ).join('<br>')}
          `;
          //console.log("‚úÖ Products have different delivery info, showing individual lines");
        }
        
        //console.log("‚úÖ Updating delivery container with:", deliveryHTML);
        deliveryContainer.innerHTML = deliveryHTML;
      } else {
        //console.log("‚ö†Ô∏è No delivery results, showing fallback message");
        deliveryContainer.innerHTML = '<strong>ESTIMATED DELIVERY BETWEEN</strong> <strong>Contact us for delivery information</strong>';
      }
    } else {
      //console.error("‚ùå Delivery container not found!");
    }

    // Update hidden input for cart properties
    const bundleDeliveryInput = document.querySelector('input[name="bundleDelivery"]');
    //console.log("üìù Bundle delivery input found:", bundleDeliveryInput);
    
    if (bundleDeliveryInput && deliveryResults.length > 0) {
      // Check if all products have the same delivery info for cart properties too
      const uniqueDeliveryValues = [...new Set(deliveryResults.map(result => result.deliveryValue))];
      
      let combinedString;
      if (uniqueDeliveryValues.length === 1) {
        // All products have same delivery info - simplified cart property
        combinedString = `All products: ${uniqueDeliveryValues[0]}`;
        //console.log("‚úÖ Unified cart property (same delivery for all):", combinedString);
      } else {
        // Different delivery info - individual cart properties
        combinedString = deliveryResults
          .map(result => `${result.productTitle}: ${result.deliveryValue}`)
          .join(', ');
        //console.log("‚úÖ Individual cart property (different delivery):", combinedString);
      }
      
      bundleDeliveryInput.value = combinedString;
      
      // Store bundle info globally for cart attributes
      window.currentBundleDelivery = {
        variantId: window.productData.selected_or_first_available_variant.id,
        deliveryInfo: combinedString
      };
      console.log('üíæ Stored bundle delivery info globally:', window.currentBundleDelivery);
      
    } else if (bundleDeliveryInput) {
      //console.log("‚ö†Ô∏è Bundle delivery input found but no results to set");
    } else {
      //console.error("‚ùå Bundle delivery input not found!");
    }
  }

  // Initial update
  console.log("üöÄ Running initial bundle delivery update...");
  updateBundleDelivery();
  
  // Show current cart attributes on page load
  fetch('/cart.js', { cache: 'no-store' })
    .then(r => r.json())
    .then(cart => {
      console.log('üìã CART ATTRIBUTES ON PAGE LOAD:', cart.attributes);
    })
    .catch(error => console.error('‚ùå Error fetching cart:', error));

  // Listen for variant changes
  const variantInput = document.querySelector('.product__main__content input[name="id"]');
  if (variantInput) {
    //console.log("‚úÖ Event listener attached to variant input");
    variantInput.addEventListener("change", updateBundleDelivery);
  } else {
    //console.error("‚ùå Could not attach event listener - variant input not found");
  }
  
  //console.log("üèÅ Bundle delivery initialization complete");
});
</script> 