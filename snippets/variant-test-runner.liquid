  <!-- Add this to your theme.liquid in the <head> section -->
<script src="https://cdn.jsdelivr.net/npm/@growthbook/growthbook/dist/bundles/auto.min.js" 
        data-api-host="https://cdn.growthbook.io"
        data-client-key="sdk-Knbwv55oDrfYDuq"
        data-enable-dev-mode>
</script>
<script>
  // Configuration
  const GB_API_KEY = 'secret_admin_wnzHrHZzdNquNDZ6KguCj0576F1SU6cpu0eVgGk8JQ';
  const GB_API_URL = 'https://api.growthbook.io/api/v1';
  
  // Debug mode - set to true for detailed logging
  const DEBUG_MODE = true;
  
  // Helper function for debug logging
  function debugLog(message, data = null) {
    if (DEBUG_MODE) {
      if (data !== null) {
        console.log(`[GB] ${message}`, data);
      } else {
        console.log(`[GB] ${message}`);
      }
    }
  }
  
  // NEW: Returning user functionality
  function setReturningUserAttribute(gb) {
    const isReturning = document.cookie.includes('gb_returning=true');
    if (!isReturning) {
      document.cookie = 'gb_returning=true; max-age=2592000; path=/';
    }
    gb.setAttributes({
      ...gb.getAttributes(),
      isReturningUser: isReturning
    });
  }

// NEW: Enhanced targeting condition evaluation
function evaluateTargetingCondition(condition, attributes) {
  if (!condition || Object.keys(condition).length === 0) {
    return { passed: true, reason: 'No targeting conditions' };
  }

  try {
    // Handle different condition formats
    if (typeof condition === 'string') {
      try {
        condition = JSON.parse(condition);
      } catch (e) {
        return { passed: true, reason: 'Invalid JSON condition, defaulting to pass' };
      }
    }

    // Check each condition
    for (const [key, expectedValue] of Object.entries(condition)) {
      const userValue = attributes[key];
      
      if (typeof expectedValue === 'object' && expectedValue !== null) {
        // Handle operators like $in, $eq, $regex, etc.
        if (expectedValue.$in && Array.isArray(expectedValue.$in)) {
          if (!expectedValue.$in.includes(userValue)) {
            return { 
              passed: false, 
              reason: `${key} targeting failed: Expected one of [${expectedValue.$in.join(', ')}], got "${userValue}"` 
            };
          }
        } else if (expectedValue.$nin && Array.isArray(expectedValue.$nin)) {
          if (expectedValue.$nin.includes(userValue)) {
            return { 
              passed: false, 
              reason: `${key} targeting failed: Expected NOT one of [${expectedValue.$nin.join(', ')}], got "${userValue}"` 
            };
          }
        } else if (expectedValue.$eq !== undefined) {
          if (userValue !== expectedValue.$eq) {
            return { 
              passed: false, 
              reason: `${key} targeting failed: Expected "${expectedValue.$eq}", got "${userValue}"` 
            };
          }
        } else if (expectedValue.$ne !== undefined) {
          if (userValue === expectedValue.$ne) {
            return { 
              passed: false, 
              reason: `${key} targeting failed: Expected NOT "${expectedValue.$ne}", but got "${userValue}"` 
            };
          }
        } else if (expectedValue.$regex) {
          try {
            const regex = new RegExp(expectedValue.$regex);
            if (!regex.test(userValue)) {
              return { 
                passed: false, 
                reason: `${key} targeting failed: Expected to match regex "${expectedValue.$regex}", got "${userValue}"` 
              };
            }
          } catch (regexError) {
            return { 
              passed: false, 
              reason: `${key} targeting failed: Invalid regex pattern "${expectedValue.$regex}"` 
            };
          }
        } else if (expectedValue.$not && expectedValue.$not.$regex) {
          try {
            const regex = new RegExp(expectedValue.$not.$regex);
            if (regex.test(userValue)) {
              return { 
                passed: false, 
                reason: `${key} targeting failed: Expected NOT to match regex "${expectedValue.$not.$regex}", but got "${userValue}"` 
              };
            }
          } catch (regexError) {
            return { 
              passed: false, 
              reason: `${key} targeting failed: Invalid regex pattern "${expectedValue.$not.$regex}"` 
            };
          }
        } else if (expectedValue.$gt !== undefined) {
          const numUserValue = Number(userValue);
          const numExpectedValue = Number(expectedValue.$gt);
          if (isNaN(numUserValue) || numUserValue <= numExpectedValue) {
            return { 
              passed: false, 
              reason: `${key} targeting failed: Expected > ${expectedValue.$gt}, got "${userValue}"` 
            };
          }
        } else if (expectedValue.$gte !== undefined) {
          const numUserValue = Number(userValue);
          const numExpectedValue = Number(expectedValue.$gte);
          if (isNaN(numUserValue) || numUserValue < numExpectedValue) {
            return { 
              passed: false, 
              reason: `${key} targeting failed: Expected >= ${expectedValue.$gte}, got "${userValue}"` 
            };
          }
        } else if (expectedValue.$lt !== undefined) {
          const numUserValue = Number(userValue);
          const numExpectedValue = Number(expectedValue.$lt);
          if (isNaN(numUserValue) || numUserValue >= numExpectedValue) {
            return { 
              passed: false, 
              reason: `${key} targeting failed: Expected < ${expectedValue.$lt}, got "${userValue}"` 
            };
          }
        } else if (expectedValue.$lte !== undefined) {
          const numUserValue = Number(userValue);
          const numExpectedValue = Number(expectedValue.$lte);
          if (isNaN(numUserValue) || numUserValue > numExpectedValue) {
            return { 
              passed: false, 
              reason: `${key} targeting failed: Expected <= ${expectedValue.$lte}, got "${userValue}"` 
            };
          }
        }
      } else {
        // Simple equality check
        if (userValue !== expectedValue) {
          return { 
            passed: false, 
            reason: `${key} targeting failed: Expected "${expectedValue}", got "${userValue}"` 
          };
        }
      }
    }
    
    return { passed: true, reason: 'All targeting conditions passed' };
  } catch (error) {
    return { passed: true, reason: `Targeting evaluation error: ${error.message}` };
  }
}
  
  console.group('üöÄ GrowthBook Script Initialization');
  debugLog('Script initialization started');
  
  // Check for preview parameters in URL
  function getPreviewExperiments() {
    const urlParams = new URLSearchParams(window.location.search);
    const previews = {};
    
    for (const [key, value] of urlParams) {
      if (key.startsWith('EXP') || key.startsWith('exp_')) {
        previews[key] = parseInt(value);
      }
    }
    
    return previews;
  }
  
  // Fetch feature flag from API for preview
  async function fetchFeatureFlag(experimentId) {
    const featureFlagId = `exp-${experimentId}`;
    debugLog(`üì° Fetching feature flag for preview: ${featureFlagId}`);
    
    try {
      const response = await fetch(`${GB_API_URL}/features/${featureFlagId}`, {
        headers: {
          'Authorization': `Bearer ${GB_API_KEY}`
        }
      });
      
      if (!response.ok) {
        throw new Error(`Failed to fetch: ${response.status}`);
      }
      
      const data = await response.json();
      return data.feature;
    } catch (error) {
      debugLog(`‚ùå Error fetching feature flag ${featureFlagId}:`, error);
      return null;
    }
  }
  
  // Apply preview experiments (overrides SDK experiments)
  async function applyPreviewExperiments() {
    const previews = getPreviewExperiments();
    
    if (Object.keys(previews).length === 0) {
      debugLog('No preview parameters found');
      return;
    }
    
    console.group(`üî¨ Preview Mode - ${Object.keys(previews).length} experiment(s)`);
    debugLog(`Active previews: ${Object.keys(previews).join(', ')}`);
    
    // Initialize test assignments if needed
    if (!window.gbTestAssignments) {
      window.gbTestAssignments = {};
    }
    
    for (const [experimentId, variantIndex] of Object.entries(previews)) {
      console.group(`üìå Preview: ${experimentId} ‚Üí Variant ${variantIndex}`);
      
      const feature = await fetchFeatureFlag(experimentId);
      
      if (!feature) {
        debugLog(`‚ùå Could not fetch feature flag for ${experimentId}`);
        console.groupEnd();
        continue;
      }
      
      const productionRules = feature.environments?.production?.rules || [];
      const rule = productionRules.find(r => r.type === 'experiment-ref');
      
      if (!rule || !rule.variations || variantIndex >= rule.variations.length) {
        debugLog(`‚ùå Invalid configuration for ${experimentId}`);
        console.groupEnd();
        continue;
      }
      
      const variation = rule.variations[variantIndex];
      const jsCode = variation.value;
      
      // Add to test assignments for pixel tracking - ALIGNED WITH DB EXPECTATIONS
      window.gbTestAssignments[experimentId] = {
        included: true,
        variationId: variantIndex,
        exclusion_reason: null,
        experiment_name: `Preview: ${experimentId}`,  // Changed from 'name' to 'experiment_name'
        hypothesis: null,
        status: 'preview'
      };
      
      if (jsCode && jsCode.trim()) {
        debugLog(`üéØ Executing preview JavaScript for ${experimentId}`);
        try {
          // Execute immediately to override any SDK experiments
          new Function(jsCode)();
          debugLog(`‚úÖ Preview override applied successfully`);
        } catch (error) {
          debugLog(`‚ùå Error executing preview:`, error);
        }
      } else {
        debugLog(`‚ö†Ô∏è No JavaScript code for variant ${variantIndex} (control group)`);
      }
      
      console.groupEnd(); // End individual preview
    }
    
    // Dispatch variant:ready event after preview assignments
    const event = new CustomEvent('variant:ready', {
      detail: {
        assignments: window.gbTestAssignments,
        timestamp: new Date().toISOString()
      }
    });
    document.dispatchEvent(event);
    debugLog('üì® Dispatched variant:ready event with preview assignments');
    
    console.groupEnd(); // End preview mode group
  }
  
  // Apply regular SDK experiments
  function applySDKExperiments() {
    const gb = window.growthbook || window._growthbook;
    
    if (!gb) {
      debugLog('‚ùå GrowthBook not initialized');
      return;
    }
    
    const features = gb.getFeatures();
    const experiments = Object.keys(features).filter(key => key.startsWith('exp-'));
    
    console.group(`üì¶ SDK Experiments (${experiments.length} found)`);
    debugLog(`Processing ${experiments.length} experiments from ${Object.keys(features).length} total features`);
    
    // Track what experiments are executed
    const executedExperiments = [];
    const skippedExperiments = [];
    
    // Initialize test assignments object
    const testAssignments = {};
    
    experiments.forEach((featureKey, index) => {
      const feature = features[featureKey];
      
      console.groupCollapsed(`üìä ${featureKey} (${index + 1}/${experiments.length})`);
      
      // Feature configuration
      console.group('üìã Feature Configuration');
      debugLog(`Default Value: "${feature.defaultValue || ''}"`);
      debugLog(`Has Rules: ${feature.rules && feature.rules.length > 0 ? 'Yes' : 'No'}`);
      debugLog(`Rule Count: ${feature.rules?.length || 0}`);
      console.groupEnd();
      
      // Check if it has rules (active) or is draft
      if (!feature.rules || feature.rules.length === 0) {
        debugLog(`‚è≠Ô∏è STATUS: DRAFT (no rules) - Skipping`);
        skippedExperiments.push({ key: featureKey, reason: 'draft' });
        
        // Add to test assignments as disabled - ALIGNED WITH DB EXPECTATIONS
        const cleanId = featureKey.replace(/^exp-/, '');
        testAssignments[cleanId] = {
          included: false,
          variationId: null,
          exclusion_reason: 'experiment_disabled',
          experiment_name: null,  // Changed from 'name' to 'experiment_name'
          hypothesis: null,
          status: 'draft'
        };
        
        console.groupEnd();
        return;
      }
      
      // Rule details
      const rule = feature.rules[0];
      console.group('üéØ Rule Details');
      debugLog(`Rule ID: ${rule.id || 'none'}`);
      debugLog(`Rule Name: ${rule.name || 'Unnamed'}`);
      debugLog(`Coverage: ${(rule.coverage * 100).toFixed(1)}%`);
      debugLog(`Hash Attribute: ${rule.hashAttribute || 'default'}`);
      debugLog(`Hash Version: ${rule.hashVersion || 'unknown'}`);
      debugLog(`Seed: ${rule.seed || 'none'}`);
      debugLog(`Phase: ${rule.phase || 'unknown'}`);
      debugLog(`Variations: ${rule.variations?.length || 0}`);
      debugLog(`Weights: [${rule.weights?.map(w => (w * 100).toFixed(1) + '%').join(', ') || 'equal'}]`);
      console.groupEnd();

      // NEW: Enhanced targeting analysis
      console.group('üéØ Targeting Analysis');
      const userAttributes = gb.getAttributes();
      debugLog('Current User Attributes:', userAttributes);
      
      if (rule.condition) {
        debugLog('Targeting Conditions:', rule.condition);
        const targetingResult = evaluateTargetingCondition(rule.condition, userAttributes);
        debugLog(`Targeting Result: ${targetingResult.passed ? '‚úÖ PASSED' : '‚ùå FAILED'}`);
        debugLog(`Targeting Reason: ${targetingResult.reason}`);
      } else {
        debugLog('Targeting Conditions: None (all users eligible)');
      }
      console.groupEnd();
      
      // Meta information
      if (rule.meta && rule.meta.length > 0) {
        console.group('üìù Variation Meta');
        rule.meta.forEach((m, i) => {
          debugLog(`Variation ${i}: ${m.name} (key: ${m.key})`);
        });
        console.groupEnd();
      }
      
      // Evaluate the feature
      const result = gb.evalFeature(featureKey);
      
      // User assignment details
      console.group('üé≤ User Assignment');
      const inExp = result.inExperiment || (result.experimentResult && result.experimentResult.inExperiment);
      const variantId = result.variationId !== undefined ? result.variationId : result.experimentResult?.variationId;
      
      debugLog(`In Experiment: ${inExp ? '‚úÖ Yes' : '‚ùå No'}`);
      debugLog(`Variant ID: ${variantId !== undefined ? variantId : 'none'}`);
      debugLog(`Has Value: ${result.value ? '‚úÖ Yes' : '‚ùå No'}`);
      debugLog(`Source: ${result.source || 'unknown'}`);
      debugLog(`Rule ID: ${result.ruleId || 'none'}`);
      console.groupEnd();
      
      // Collect assignment for pixel tracking - ALIGNED WITH DB EXPECTATIONS
      const cleanId = featureKey.replace(/^exp-/, '');
      let exclusionReason = null;
      let included = false;
      
      // Determine inclusion and exclusion reason
      if (inExp && variantId !== undefined) {
        // User is in experiment
        included = true;
        // Control group still counts as included but we can note it
        if (variantId === 0) {
          // Control group - still included but can be tracked separately
          exclusionReason = null; // No exclusion for control group
        }
      } else if (!inExp) {
        // User is NOT in experiment
        included = false;
        
        // Determine why they're excluded
        if (rule.condition) {
          const targetingResult = evaluateTargetingCondition(rule.condition, userAttributes);
          if (!targetingResult.passed) {
            exclusionReason = 'targeting_failed';
          } else {
            exclusionReason = 'traffic_allocation';
          }
        } else {
          exclusionReason = 'traffic_allocation';
        }
      } else {
        // Edge case: no variant ID
        included = false;
        exclusionReason = 'no_variant';
      }
      
      // Structure matching DB expectations exactly
      testAssignments[cleanId] = {
        included: included,
        variationId: included ? variantId : null,  // Only set if included
        exclusion_reason: exclusionReason,
        experiment_name: rule.name || rule.meta?.[0]?.name || cleanId,  // Changed from 'name' to 'experiment_name'
        hypothesis: null,
        status: 'active'
      };
      
      // Experiment result details (hash calculation)
      if (result.experimentResult) {
        console.group('üî¢ Hash Calculation');
        debugLog(`Hash Attribute: ${result.experimentResult.hashAttribute}`);
        debugLog(`Hash Value: ${result.experimentResult.hashValue}`);
        debugLog(`Bucket: ${result.experimentResult.bucket?.toFixed(4) || 'unknown'}`);
        debugLog(`In Experiment: ${result.experimentResult.inExperiment ? '‚úÖ' : '‚ùå'}`);
        debugLog(`Variation ID: ${result.experimentResult.variationId}`);
        debugLog(`Key: ${result.experimentResult.key || 'none'}`);
        debugLog(`Feature ID: ${result.experimentResult.featureId || featureKey}`);
        
        // Bucket range calculation
        if (rule.weights && variantId !== undefined) {
          let start = 0;
          let end = 0;
          for (let i = 0; i <= variantId; i++) {
            end += rule.weights[i];
            if (i < variantId) start += rule.weights[i];
          }
          console.group('üìè Bucket Range');
          debugLog(`Variant ${variantId} Range: [${start.toFixed(3)} - ${end.toFixed(3)}]`);
          debugLog(`User Bucket: ${result.experimentResult.bucket?.toFixed(4)}`);
          debugLog(`Falls in Range: ${result.experimentResult.bucket >= start && result.experimentResult.bucket < end ? '‚úÖ Yes' : '‚ùå No'}`);
          console.groupEnd();
        }
        console.groupEnd();
      }
      
      // Enhanced execution decision - UPDATED TO HANDLE FORCE RULES WITH TARGETING
      console.group('‚ö° Execution Decision');
      
      // Check if this is a force rule that needs targeting evaluation
      let shouldExecute = true;
      if (result.source === 'force' && rule.condition) {
        const targetingResult = evaluateTargetingCondition(rule.condition, userAttributes);
        if (!targetingResult.passed) {
          shouldExecute = false;
          debugLog(`Status: ‚ùå FORCE RULE TARGETING FAILED`);
          debugLog(`Targeting Details: ${targetingResult.reason}`);
          skippedExperiments.push({ 
            key: featureKey, 
            reason: 'force_targeting_failed',
            details: targetingResult.reason 
          });
        }
      }
      
      if (shouldExecute && result.value && typeof result.value === 'string' && result.value.trim()) {
        debugLog(`Status: ‚úÖ WILL EXECUTE`);
        debugLog(`Variant: ${variantId}`);
        debugLog(`Code Length: ${result.value.length} chars`);
        debugLog(`Code Preview: ${result.value.substring(0, 80).replace(/\n/g, ' ')}...`);
        
        try {
          new Function(result.value)();
          executedExperiments.push({
            key: featureKey,
            variant: variantId,
            name: rule.name || featureKey,
            source: result.source
          });
          debugLog(`‚úÖ EXECUTION RESULT: Success`);
        } catch (error) {
          debugLog(`‚ùå EXECUTION ERROR: ${error.message}`);
          skippedExperiments.push({ key: featureKey, reason: 'error', error: error.message });
        }
      } else if (!shouldExecute) {
        // Already handled above for force rule targeting
      } else {
        // Enhanced exclusion reason analysis
        if (variantId === 0) {
          debugLog(`Status: ‚ö™ CONTROL GROUP`);
          debugLog(`Variant: 0 (Control)`);
          debugLog(`Reason: No code for control group`);
          skippedExperiments.push({ key: featureKey, reason: 'control', variant: 0 });
        } else if (!inExp) {
          debugLog(`Status: ‚ùå NOT IN EXPERIMENT`);
          
          // NEW: Enhanced exclusion analysis
          if (rule.condition) {
            const userAttributes = gb.getAttributes();
            const targetingResult = evaluateTargetingCondition(rule.condition, userAttributes);
            if (!targetingResult.passed) {
              debugLog(`Exclusion Reason: üéØ TARGETING FAILED`);
              debugLog(`Targeting Details: ${targetingResult.reason}`);
              skippedExperiments.push({ 
                key: featureKey, 
                reason: 'targeting_failed',
                details: targetingResult.reason 
              });
            } else {
              debugLog(`Exclusion Reason: üìä TRAFFIC ALLOCATION`);
              debugLog(`User's hash fell outside the ${(rule.coverage * 100).toFixed(1)}% coverage`);
              skippedExperiments.push({ 
                key: featureKey, 
                reason: 'traffic_allocation',
                coverage: rule.coverage * 100
              });
            }
          } else {
            debugLog(`Exclusion Reason: üìä TRAFFIC ALLOCATION`);
            debugLog(`User's hash fell outside the ${(rule.coverage * 100).toFixed(1)}% coverage`);
            skippedExperiments.push({ 
              key: featureKey, 
              reason: 'traffic_allocation',
              coverage: rule.coverage * 100
            });
          }
        } else if (!result.value) {
          debugLog(`Status: ‚ùå NO VALUE`);
          debugLog(`Reason: No JavaScript code returned`);
          skippedExperiments.push({ key: featureKey, reason: 'no_value' });
        } else {
          debugLog(`Status: ‚ö†Ô∏è UNKNOWN`);
          debugLog(`Reason: Unable to determine`);
          skippedExperiments.push({ key: featureKey, reason: 'unknown' });
        }
      }
      console.groupEnd(); // End execution decision
      
      console.groupEnd(); // End individual experiment
    });
    
    // Store test assignments globally for pixel
    window.gbTestAssignments = testAssignments;
    
    // Store in localStorage
    try {
      localStorage.setItem('gb_active_tests', JSON.stringify(testAssignments));
      debugLog('‚úÖ Stored test assignments in localStorage');
    } catch(e) {
      debugLog('‚ö†Ô∏è Could not store in localStorage:', e);
    }
    
    // Dispatch variant:ready event for pixel
    const event = new CustomEvent('variant:ready', {
      detail: {
        assignments: testAssignments,
        timestamp: new Date().toISOString()
      }
    });
    document.dispatchEvent(event);
    debugLog('üì® Dispatched variant:ready event with assignments:', testAssignments);
    
    // Final summary
    console.group('üìä Execution Summary');
    debugLog(`‚úÖ Executed: ${executedExperiments.length} experiments`);
    if (executedExperiments.length > 0) {
      console.group('Executed Experiments');
      executedExperiments.forEach(exp => {
        debugLog(`${exp.key} (variant ${exp.variant}) [${exp.source}]`);
      });
      console.groupEnd();
    }
    
    debugLog(`‚è≠Ô∏è Skipped: ${skippedExperiments.length} experiments`);
    if (skippedExperiments.length > 0) {
      console.group('Skipped Experiments');
      skippedExperiments.forEach(exp => {
        if (exp.details) {
          debugLog(`${exp.key} (${exp.reason}) - ${exp.details}`);
        } else if (exp.coverage) {
          debugLog(`${exp.key} (${exp.reason}) - ${exp.coverage}% coverage`);
        } else {
          debugLog(`${exp.key} (${exp.reason}${exp.variant !== undefined ? ` - variant ${exp.variant}` : ''})`);
        }
      });
      console.groupEnd();
    }
    console.groupEnd(); // End execution summary
    
    console.groupEnd(); // End SDK experiments group
    
    // Store summary for debugging
    window.__gbExecutionSummary = {
      executed: executedExperiments,
      skipped: skippedExperiments,
      assignments: testAssignments,
      timestamp: new Date().toISOString()
    };
  }
  
  // Main initialization sequence
  async function initializeExperiments() {
    console.group('üé¨ Experiment Initialization Sequence');
    
    const gb = window.growthbook || window._growthbook;
    
    // Step 1: Apply SDK experiments first
    if (gb) {
      debugLog('Step 1: Applying SDK experiments');
      applySDKExperiments();
    } else {
      debugLog('‚ö†Ô∏è GrowthBook not ready, will apply SDK experiments when ready');
    }
    
    // Step 2: Apply preview overrides (if any)
    const previews = getPreviewExperiments();
    if (Object.keys(previews).length > 0) {
      debugLog('Step 2: Applying preview overrides');
      await applyPreviewExperiments();
    }
    
    debugLog('‚úÖ Initialization sequence complete');
    console.groupEnd();
  }
  
  // Wait for GrowthBook to be ready
window.addEventListener('growthbookready', async function() {
  console.group('üéâ GrowthBook Ready Event');
  debugLog('GrowthBook ready event fired');
  
  const gb = window.growthbook || window._growthbook;
  
  if (gb) {
    // Create alias if needed
    if (!window.growthbook && window._growthbook) {
      window.growthbook = window._growthbook;
      debugLog('Created alias: window.growthbook = window._growthbook');
    }
    
    debugLog('GrowthBook initialized successfully at:', window._growthbook ? 'window._growthbook' : 'window.growthbook');
    
    // Set returning user attribute
    setReturningUserAttribute(gb);
    
    // Run the initialization sequence
    await initializeExperiments();
  }
  console.groupEnd();
});
  
  // Fallback: If GrowthBook is already ready when script loads
  const existingGb = window.growthbook || window._growthbook;
  if (existingGb && existingGb.ready) {
    console.group('‚ö° GrowthBook Already Ready');
    debugLog('GrowthBook already initialized, running experiments');
    if (!window.growthbook && window._growthbook) {
      window.growthbook = window._growthbook;
    }
    
    // Set returning user attribute
    setReturningUserAttribute(existingGb);
    
    initializeExperiments();
    console.groupEnd();
  }
  
  // Additional fallback: DOM ready
  document.addEventListener('DOMContentLoaded', function() {
    // Check if we have preview params but haven't processed them yet
    const previews = getPreviewExperiments();
    if (Object.keys(previews).length > 0) {
      console.group('üìÑ DOM Ready - Preview Check');
      debugLog('DOM ready - ensuring preview overrides are applied');
      
      // Give SDK experiments time to load first
      setTimeout(async () => {
        const gb = window.growthbook || window._growthbook;
        
        // If GrowthBook is ready, reinitialize to ensure proper order
        if (gb) {
          // Set returning user attribute
          setReturningUserAttribute(gb);
          
          await initializeExperiments();
        } else {
          // Just apply previews if GrowthBook isn't ready
          debugLog('Applying preview overrides without SDK');
          await applyPreviewExperiments();
        }
      }, 500);
      console.groupEnd();
    }
  });
  
  // Window load fallback - final safety net
  window.addEventListener('load', function() {
    console.group('üèÅ Window Load - Final Check');
    debugLog('Window load event - final GrowthBook check');
    
    setTimeout(() => {
      const gb = window.growthbook || window._growthbook;
      if (gb && !window.growthbook) {
        window.growthbook = gb;
        debugLog('Created alias at window load: window.growthbook = window._growthbook');
      }
      
      // If we haven't initialized yet, do it now
      if (gb && !window.__gbInitialized) {
        debugLog('Running initialization from window load');
        window.__gbInitialized = true;
        
        // Set returning user attribute
        setReturningUserAttribute(gb);
        
        initializeExperiments();
      }
    }, 1000);
    console.groupEnd();
  });
  
  // Enhanced debug helper
  window.gbDebug = function() {
    console.group('üîç GROWTHBOOK DEBUG REPORT');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    
    const gb = window.growthbook || window._growthbook;
    
    if (!gb) {
      console.log('‚ùå GrowthBook not initialized');
      console.log('Checked locations:');
      console.log('- window.growthbook:', window.growthbook);
      console.log('- window._growthbook:', window._growthbook);
      console.groupEnd();
      return;
    }
    
    console.group('üìä Status');
    console.log('Location:', window._growthbook ? 'window._growthbook' : 'window.growthbook');
    console.log('Ready:', gb.ready);
    console.log('Features:', Object.keys(gb.getFeatures()).length);
    console.log('Attributes:', gb.getAttributes());
    console.groupEnd();
    
    console.group('üß™ All Experiments (exp-*)');
    const features = gb.getFeatures();
    const experiments = Object.keys(features).filter(k => k.startsWith('exp-'));
    
    experiments.forEach(key => {
      const feature = features[key];
      const result = gb.evalFeature(key);
      const isActive = feature.rules && feature.rules.length > 0;
      const inExperiment = result.inExperiment || (result.experimentResult && result.experimentResult.inExperiment);
      const variantId = result.variationId !== undefined ? result.variationId : result.experimentResult?.variationId;
      
      console.group(key);
      console.log('Status:', isActive ? 'ACTIVE' : 'DRAFT');
      console.log('In Experiment:', inExperiment);
      console.log('Variant:', variantId);
      console.log('Has Value:', !!result.value);
      console.log('Source:', result.source || 'unknown');
      
      if (isActive && feature.rules[0]) {
        console.log('Coverage:', (feature.rules[0].coverage * 100) + '%');
        console.log('Variations:', feature.rules[0].variations?.length || 0);
        
        // Enhanced targeting info
        if (feature.rules[0].condition) {
          console.log('Targeting Conditions:', feature.rules[0].condition);
          const userAttributes = gb.getAttributes();
          const targetingResult = evaluateTargetingCondition(feature.rules[0].condition, userAttributes);
          console.log('Targeting Result:', targetingResult.passed ? '‚úÖ PASSED' : '‚ùå FAILED');
          console.log('Targeting Reason:', targetingResult.reason);
        }
      }
      console.groupEnd();
    });
    console.groupEnd();
    
    console.group('üìà Execution Summary');
    if (window.__gbExecutionSummary) {
      console.log('Executed:', window.__gbExecutionSummary.executed.length, 'experiments');
      if (window.__gbExecutionSummary.executed.length > 0) {
        console.group('Executed List');
        window.__gbExecutionSummary.executed.forEach(exp => {
          console.log(`‚úÖ ${exp.key} (variant ${exp.variant}) [${exp.source}]`);
        });
        console.groupEnd();
      }
      console.log('Skipped:', window.__gbExecutionSummary.skipped.length, 'experiments');
      if (window.__gbExecutionSummary.skipped.length > 0) {
        console.group('Skipped List');
        window.__gbExecutionSummary.skipped.forEach(exp => {
          if (exp.details) {
            console.log(`‚è≠Ô∏è ${exp.key} (${exp.reason}) - ${exp.details}`);
          } else if (exp.coverage) {
            console.log(`‚è≠Ô∏è ${exp.key} (${exp.reason}) - ${exp.coverage}% coverage`);
          } else {
            console.log(`‚è≠Ô∏è ${exp.key} (${exp.reason})`);
          }
        });
        console.groupEnd();
      }
      console.log('Timestamp:', window.__gbExecutionSummary.timestamp);
      
      // Show test assignments
      if (window.__gbExecutionSummary.assignments) {
        console.group('Test Assignments');
        console.log('Total:', Object.keys(window.__gbExecutionSummary.assignments).length);
        console.log('Assignments:', window.__gbExecutionSummary.assignments);
        console.groupEnd();
      }
    } else {
      console.log('No execution summary available');
    }
    console.groupEnd();
    
    console.group('üîó Preview Parameters');
    console.log(getPreviewExperiments());
    console.groupEnd();
    
    console.group('üéØ Target Element Check');
    const heading = document.querySelector('.v-stack.justify-self-center h2.h2');
    console.log(heading ? `Found: "${heading.textContent}"` : 'Not found');
    console.groupEnd();
    
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.groupEnd();
  };
  
  // Force preview helper
  window.forcePreview = async function(experimentId, variantIndex) {
    console.group(`üîß Force Preview: ${experimentId}`);
    console.log(`Forcing preview: ${experimentId} variant ${variantIndex}`);
    const previews = {};
    previews[experimentId] = variantIndex;
    
    for (const [expId, variant] of Object.entries(previews)) {
      const feature = await fetchFeatureFlag(expId);
      if (feature) {
        const rule = feature.environments?.production?.rules?.find(r => r.type === 'experiment-ref');
        if (rule && rule.variations[variant]) {
          const jsCode = rule.variations[variant].value;
          if (jsCode) {
            new Function(jsCode)();
            console.log('‚úÖ Preview applied');
          }
        }
      }
    }
    console.groupEnd();
  };
  
  debugLog('‚úÖ GrowthBook integration loaded');
  debugLog('üí° Use gbDebug() for status, forcePreview("EXP91264", 1) to test');
  console.groupEnd(); // End initial script initialization group
</script>