<!-- GrowthBook Auto-Bundle with Analytics Pixel Integration -->
<!-- Place this in your theme.liquid file -->

<!-- Anti-flicker styles -->
<style>
  [data-gb-gate] {
    visibility: hidden;
    transition: visibility 0.2s ease-in-out;
  }
  .gb-ready [data-gb-gate] {
    visibility: visible;
  }
  .gb-timeout [data-gb-gate] {
    visibility: visible;
  }
</style>

<script>
// ============================================
// STABLE USER ID & CONFIGURATION
// ============================================
(function() {
  'use strict';
  
  // Get or create stable user ID (shared with pixel)
  const USER_ID_KEY = 'gb_anonymous_id'; // Matches pixel's expectation
  let stableUserId = localStorage.getItem(USER_ID_KEY);
  
  if (!stableUserId) {
    stableUserId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    localStorage.setItem(USER_ID_KEY, stableUserId);
    console.log('[GB] Created new stable user ID:', stableUserId);
  } else {
    console.log('[GB] Using existing stable user ID:', stableUserId);
  }
  
  // Also store as gb_stable_user_id for backward compatibility
  localStorage.setItem('gb_stable_user_id', stableUserId);
  
  // Store globally for debugging
  window.GB_STABLE_USER_ID = stableUserId;
  
  // Configuration for preview system
  window.GB_PREVIEW_CONFIG = {
    enabled: true,
    patterns: [/^EXP\d+$/, /^exp_\w+$/, /^test_\w+$/],
    overrides: new Map()
  };
  
  // Pre-configure GrowthBook with stable ID
  window.growthbook_config = {
    apiHost: "https://cdn.growthbook.io",
    clientKey: "sdk-Knbwv55oDrfYDuq",
    enableDevMode: /[?&]debug=1(&|$)/.test(location.search),
    
    attributes: {
      id: stableUserId, // Our stable ID
      
      // Shopify attributes
      customerId: window.ShopifyAnalytics?.meta?.page?.customerId || null,
      pageType: window.ShopifyAnalytics?.meta?.page?.pageType || 'unknown',
      
      // Device detection  
      deviceType: /Mobile|Android|iPhone|iPad/i.test(navigator.userAgent) ? 'mobile' : 'desktop',
      browser: (function() {
        const ua = navigator.userAgent;
        if (ua.includes('Chrome') && !ua.includes('Edge')) return 'chrome';
        if (ua.includes('Safari') && !ua.includes('Chrome')) return 'safari';  
        if (ua.includes('Firefox')) return 'firefox';
        if (ua.includes('Edge')) return 'edge';
        return 'other';
      })(),
      
      // Page attributes
      url: location.href,
      path: location.pathname,
      domain: location.hostname
    },
    
    trackingCallback: function(experiment, result) {
      const debug = /[?&]debug=1(&|$)/.test(location.search);
      if (debug) {
        console.log('[GB] Experiment viewed:', experiment.key, {
          variation: result.variationId,
          bucket: result.experimentResult?.bucket
        });
      }
      
      // Analytics tracking
      if (window.dataLayer) {
        window.dataLayer.push({
          event: 'gb_experiment_viewed',
          experimentId: experiment.key,
          variationId: result.variationId
        });
      }
    }
  };
})();

// Load GrowthBook auto-bundle
(function() {
  const script = document.createElement('script');
  script.async = true;
  script.src = 'https://cdn.jsdelivr.net/npm/@growthbook/growthbook/dist/bundles/auto.min.js';
  script.dataset.apiHost = 'https://cdn.growthbook.io';
  script.dataset.clientKey = 'sdk-Knbwv55oDrfYDuq';
  document.head.appendChild(script);
})();

// ============================================  
// EXPERIMENT HANDLER WITH ANALYTICS INTEGRATION
// ============================================
(function() {
  const DEBUG = /[?&]debug=1(&|$)/.test(location.search);
  
  // Track execution state
  window.GB_EXECUTION = {
    ready: false,
    executed: new Set(),
    evaluations: {},
    previews: new Map()
  };
  
  // Initialize gbTestAssignments immediately as empty
  window.gbTestAssignments = {};
  
  // Check for preview experiments in URL
  function getPreviewExperiments() {
    if (!window.GB_PREVIEW_CONFIG?.enabled) return {};
    
    const urlParams = new URLSearchParams(window.location.search);
    const previews = {};
    
    for (const [key, value] of urlParams) {
      const isExperimentParam = window.GB_PREVIEW_CONFIG.patterns.some(pattern => pattern.test(key));
      if (isExperimentParam) {
        const variantIndex = parseInt(value);
        if (!isNaN(variantIndex)) {
          previews[key] = variantIndex;
        }
      }
    }
    
    return previews;
  }
  
  // Apply preview overrides after normal execution
  async function applyPreviewOverrides(gb) {
    const previews = getPreviewExperiments();
    if (Object.keys(previews).length === 0) return;
    
    console.log('[GB] Preview mode enabled:', previews);
    
    // Get all features to check variations
    const features = gb.getFeatures();
    
    for (const [param, variantIndex] of Object.entries(previews)) {
      let experimentKey = `exp-${param}`;
      
      // Handle different naming formats
      if (param.startsWith('EXP')) {
        experimentKey = `exp-${param}`;
      } else if (param.startsWith('test_')) {
        experimentKey = `exp-${param.replace('test_', '')}`;
      } else if (param.startsWith('exp_')) {
        experimentKey = `exp-${param.replace('exp_', '')}`;
      }
      
      // Check if experiment exists
      const feature = features[experimentKey];
      if (!feature) {
        console.warn(`[GB] Preview experiment ${experimentKey} not found`);
        continue;
      }
      
      // Find the rule with variations
      let previewCode = '';
      if (feature.rules && feature.rules.length > 0) {
        for (const rule of feature.rules) {
          if (rule.variations && variantIndex < rule.variations.length) {
            previewCode = rule.variations[variantIndex] || '';
            break;
          }
        }
      }
      
      // If we found code for this variant, execute it
      if (previewCode && typeof previewCode === 'string' && previewCode.trim()) {
        try {
          // First, clear any previously executed version of this experiment
          const experimentId = experimentKey.replace('exp-', '');
          if (window.GB_EXECUTION.executed.has(experimentId)) {
            console.log(`[GB] Preview: Overriding previously executed ${experimentId}`);
          }
          
          new Function(previewCode)();
          window.GB_EXECUTION.previews.set(experimentId, variantIndex);
          console.log(`[GB] ✅ Preview executed: ${experimentId} variant ${variantIndex}`);
        } catch (error) {
          console.error(`[GB] Preview execution failed for ${experimentKey}:`, error);
        }
      } else {
        console.log(`[GB] Preview: No code for ${experimentKey} variant ${variantIndex}`);
      }
    }
  }
  
  // Wait for GrowthBook and execute experiments
  window.growthbook_queue = window.growthbook_queue || [];
  window.growthbook_queue.push(async function(gb) {
    console.log('[GB] Auto-bundle initialized');
    
    // Verify our stable ID is being used
    const currentId = gb.getAttributes()?.id;
    if (currentId !== window.GB_STABLE_USER_ID) {
      console.warn('[GB] Fixing ID from', currentId, 'to', window.GB_STABLE_USER_ID);
      gb.setAttributes({
        ...gb.getAttributes(),
        id: window.GB_STABLE_USER_ID
      });
    }
    
    // Function to execute experiments
    async function executeExperiments() {
      // Ensure features are loaded
      if (!gb.ready) {
        console.log('[GB] Waiting for features...');
        await gb.loadFeatures();
      }
      
      const features = gb.getFeatures();
      const experiments = Object.keys(features).filter(k => k.startsWith('exp-'));
      
      console.log('[GB] Processing', experiments.length, 'experiments');
      
      let executedCount = 0;
      let includedCount = 0;
      
      // Helper function to check condition matching
      function matchesCondition(attributes, condition) {
        // Simplified condition checking - you might need to expand this
        for (const [key, value] of Object.entries(condition)) {
          if (key === '$and') {
            return value.every(subCondition => matchesCondition(attributes, subCondition));
          }
          if (key === '$or') {
            return value.some(subCondition => matchesCondition(attributes, subCondition));
          }
          if (typeof value === 'object' && value !== null && value.$regex) {
            const regex = new RegExp(value.$regex);
            return regex.test(attributes[key]);
          }
          if (attributes[key] !== value) {
            return false;
          }
        }
        return true;
      }
      
      experiments.forEach(key => {
        const experimentId = key.replace('exp-', '');
        const result = gb.evalFeature(key);
        const feature = features[key];
        const rule = feature?.rules?.[0];
        
        // Determine if this is a real A/B test (not a force rule or disabled)
        const isABTest = rule?.variations && rule?.force === undefined;
        const isForceRule = rule?.force !== undefined;
        const isDisabled = !feature?.rules || feature.rules.length === 0;
        
        // Store evaluation details
        window.GB_EXECUTION.evaluations[experimentId] = {
          included: result?.experimentResult?.inExperiment || false,
          variation: result?.experimentResult?.variationId,
          bucket: result?.experimentResult?.bucket,
          value: result?.value,
          source: result?.source,
          reason: result?.experimentResult?.reason || null,
          isABTest: isABTest,
          isForceRule: isForceRule,
          isDisabled: isDisabled
        };
        
        // Enhanced debug logging for ALL experiments
        if (DEBUG) {
          // Determine experiment type and status
          let status = '';
          let details = {};
          
          if (isDisabled) {
            status = '⚠️ DISABLED/DRAFT';
            details = { reason: 'No rules configured' };
          } else if (isForceRule) {
            status = '🔧 FORCE RULE';
            details = {
              hasCode: !!rule.force,
              targeting: rule.condition || 'none'
            };
          } else if (isABTest) {
            status = result?.experimentResult?.inExperiment ? '✅ A/B INCLUDED' : '❌ A/B EXCLUDED';
            details = {
              variation: result?.experimentResult?.variationId,
              bucket: result?.experimentResult?.bucket?.toFixed(4),
              coverage: (rule.coverage || 1) * 100 + '%',
              targeting: rule.condition || 'none',
              source: result?.source
            };
            
            // Add exclusion reason if not included
            if (!result?.experimentResult?.inExperiment) {
              // Check targeting mismatch
              if (rule.condition && !matchesCondition(gb.getAttributes(), rule.condition)) {
                details.exclusionReason = 'targeting_mismatch';
              } else if (result?.experimentResult?.bucket > (rule.coverage || 1)) {
                details.exclusionReason = 'outside_coverage';
              } else {
                details.exclusionReason = result?.experimentResult?.reason || 'unknown';
              }
            }
          }
          
          console.log(`[GB] ${experimentId} ${status}:`, details);
        }
        
        // Track if included in A/B test
        if (result?.experimentResult?.inExperiment) {
          includedCount++;
        }
        
        // Execute JavaScript if present
        if (result?.value && typeof result.value === 'string' && result.value.trim()) {
          // Skip if already executed
          if (window.GB_EXECUTION.executed.has(experimentId)) {
            if (DEBUG) console.log(`[GB] ${experimentId} already executed, skipping`);
            return;
          }
          
          try {
            new Function(result.value)();
            window.GB_EXECUTION.executed.add(experimentId);
            executedCount++;
            
            if (DEBUG) {
              console.log(`[GB] 🚀 ${experimentId} EXECUTED`);
            }
          } catch (error) {
            console.error(`[GB] 💥 ${experimentId} EXECUTION FAILED:`, error.message);
          }
        }
      });
      
      console.log(`[GB] Complete: ${includedCount} included, ${executedCount} executed`);
      
      // Create assignments for the analytics pixel (ONLY A/B tests that are included)
      const assignments = {};
      Object.entries(window.GB_EXECUTION.evaluations).forEach(([expId, data]) => {
        // Only include actual A/B tests that the user is included in
        // Skip force rules, disabled experiments, and excluded A/B tests
        if (data.isABTest && data.included) {
          assignments[expId] = {
            experimentId: expId,
            variationId: data.variation,
            included: true,
            exclusion_reason: null,
            bucket: data.bucket,
            source: data.source,
            experiment_name: null, // Would need to extract from feature metadata if available
            hypothesis: null,
            status: 'active'
          };
        }
      });
      
      // Update global assignments
      window.gbTestAssignments = assignments;
      
      // Also store in localStorage for pixel fallback
      try {
        localStorage.setItem('gb_active_tests', JSON.stringify(assignments));
      } catch (e) {
        console.warn('[GB] Could not store assignments in localStorage:', e);
      }
      
      // Dispatch event for pixel with assignments
      const eventDetail = { 
        assignments: assignments,
        summary: {
          total_ab_tests_included: Object.keys(assignments).length,
          total_experiments: experiments.length,
          force_rules: Object.values(window.GB_EXECUTION.evaluations).filter(e => e.isForceRule).length,
          disabled: Object.values(window.GB_EXECUTION.evaluations).filter(e => e.isDisabled).length
        }
      };
      
      // Dispatch the event
      document.dispatchEvent(new CustomEvent('variant:ready', {
        detail: eventDetail
      }));
      
      console.log(`[GB] Analytics: Reporting ${Object.keys(assignments).length} included A/B tests to pixel`);
      if (DEBUG && Object.keys(assignments).length > 0) {
        console.log('[GB] Assignments sent to pixel:', assignments);
      }
      
      // After normal execution, apply preview overrides
      await applyPreviewOverrides(gb);
      
      window.GB_EXECUTION.ready = true;
      document.documentElement.classList.add('gb-ready');
      
      // Dispatch a secondary event in case the pixel missed the first one
      setTimeout(() => {
        if (Object.keys(assignments).length > 0) {
          document.dispatchEvent(new CustomEvent('gb:experiments:ready', {
            detail: { assignments: assignments }
          }));
        }
      }, 100);
    }
    
    // Execute on load
    await executeExperiments();
    
    // Re-execute on Shopify section changes
    document.addEventListener('shopify:section:load', function() {
      console.log('[GB] Section reload detected');
      window.GB_EXECUTION.executed.clear(); // Allow re-execution
      executeExperiments();
    });
    
    // Safe attribute updates for cart events  
    function updateAttributes(newAttrs) {
      gb.setAttributes({
        ...gb.getAttributes(),
        ...newAttrs,
        id: window.GB_STABLE_USER_ID // Never change ID
      });
    }
    
    document.addEventListener('cart:updated', function() {
      updateAttributes({
        cartUpdated: Date.now(),
        cartItemCount: window.Shopify?.cart?.item_count || 0
      });
    });
    
    // Monitor ID stability
    setInterval(function() {
      const currentId = gb.getAttributes()?.id;
      if (currentId !== window.GB_STABLE_USER_ID) {
        console.error('[GB] ID drift detected! Fixing...');
        gb.setAttributes({
          ...gb.getAttributes(),
          id: window.GB_STABLE_USER_ID
        });
      }
    }, 5000);
    
    // Store reference
    window.gb = gb;
  });
})();

// ============================================
// DEBUG UTILITIES  
// ============================================
window.gbDebug = function() {
  const gb = window.gb || window._growthbook;
  
  console.group('🔬 GrowthBook Debug');
  console.log('Stable ID:', window.GB_STABLE_USER_ID);
  console.log('Current ID:', gb?.getAttributes()?.id);
  console.log('Match:', gb?.getAttributes()?.id === window.GB_STABLE_USER_ID ? '✅' : '❌');
  
  if (window.GB_EXECUTION.evaluations) {
    const abTests = Object.entries(window.GB_EXECUTION.evaluations).filter(([_, data]) => data.isABTest);
    const forceRules = Object.entries(window.GB_EXECUTION.evaluations).filter(([_, data]) => data.isForceRule);
    const disabled = Object.entries(window.GB_EXECUTION.evaluations).filter(([_, data]) => data.isDisabled);
    
    console.group('A/B Tests');
    abTests.forEach(([id, data]) => {
      const status = data.included ? '✅ INCLUDED' : '❌ EXCLUDED';
      const executed = window.GB_EXECUTION.executed.has(id) ? '🚀' : '';
      console.log(`${status} ${id}: Var ${data.variation}, Bucket ${data.bucket?.toFixed(4)} ${executed}`);
    });
    console.groupEnd();
    
    console.group('Force Rules (Feature Flags)');
    forceRules.forEach(([id, data]) => {
      const executed = window.GB_EXECUTION.executed.has(id) ? '🚀 EXECUTED' : '⭕ NOT EXECUTED';
      console.log(`${id}: ${executed}`);
    });
    console.groupEnd();
    
    if (disabled.length > 0) {
      console.group('Disabled/Draft');
      disabled.forEach(([id]) => console.log(`⚠️ ${id}`));
      console.groupEnd();
    }
  }
  
  console.log('Attributes:', gb?.getAttributes());
  console.log('Analytics Assignments:', window.gbTestAssignments);
  console.groupEnd();
  
  return {
    stableId: window.GB_STABLE_USER_ID,
    currentId: gb?.getAttributes()?.id,
    evaluations: window.GB_EXECUTION.evaluations,
    analyticsAssignments: window.gbTestAssignments
  };
};

window.gbTestBucket = function(experimentId) {
  const gb = window.gb || window._growthbook;
  const key = experimentId.startsWith('exp-') ? experimentId : `exp-${experimentId}`;
  const result = gb?.evalFeature(key);
  
  console.log(`${experimentId}:`, {
    included: result?.experimentResult?.inExperiment,
    variation: result?.experimentResult?.variationId,  
    bucket: result?.experimentResult?.bucket
  });
  
  return result?.experimentResult?.bucket;
};

// Additional helper for detailed experiment analysis
window.gbAnalyze = function(experimentId) {
  const gb = window.gb || window._growthbook;
  const key = experimentId.startsWith('exp-') ? experimentId : `exp-${experimentId}`;
  const feature = gb?.getFeatures()?.[key];
  const result = gb?.evalFeature(key);
  const rule = feature?.rules?.[0];
  
  console.group(`🔍 Analysis: ${experimentId}`);
  
  if (!feature) {
    console.log('❌ Experiment not found');
  } else if (!rule) {
    console.log('⚠️ No rules configured (draft/disabled)');
  } else {
    console.log('Rule Type:', rule.force !== undefined ? 'Force Rule' : 'A/B Test');
    console.log('Targeting:', rule.condition || 'none');
    
    if (rule.variations) {
      console.log('Coverage:', (rule.coverage || 1) * 100 + '%');
      console.log('Variations:', rule.variations.length);
      console.log('Weights:', rule.weights);
    }
    
    console.log('Your Attributes:', gb.getAttributes());
    console.log('Evaluation Result:', {
      included: result?.experimentResult?.inExperiment,
      variation: result?.experimentResult?.variationId,
      bucket: result?.experimentResult?.bucket,
      source: result?.source
    });
    
    if (rule.condition) {
      console.log('Targeting Match:', 
        Object.entries(rule.condition).map(([k,v]) => {
          const attrValue = gb.getAttributes()[k];
          if (v && typeof v === 'object' && v.$regex) {
            const regex = new RegExp(v.$regex);
            return `${k}: "${attrValue}" matches ${v.$regex}? ${regex.test(attrValue)}`;
          }
          return `${k}: "${attrValue}" === ${JSON.stringify(v)}? ${attrValue === v}`;
        })
      );
    }
    
    console.log('Will report to analytics?', 
      rule.force === undefined && result?.experimentResult?.inExperiment ? 
      '✅ YES - A/B test with inclusion' : 
      '❌ NO - Force rule, disabled, or excluded from A/B test'
    );
  }
  
  console.groupEnd();
};

// Helper to verify pixel integration
window.gbPixelStatus = function() {
  console.group('📊 Pixel Integration Status');
  console.log('Test Assignments Available:', window.gbTestAssignments ? 'YES' : 'NO');
  
  if (window.gbTestAssignments) {
    const count = Object.keys(window.gbTestAssignments).length;
    console.log(`Reporting ${count} A/B test${count !== 1 ? 's' : ''} to analytics`);
    
    if (count > 0) {
      console.group('A/B Tests Being Tracked:');
      Object.entries(window.gbTestAssignments).forEach(([id, data]) => {
        console.log(`${id}: Variant ${data.variationId} (bucket: ${data.bucket?.toFixed(4)})`);
      });
      console.groupEnd();
    }
  }
  
  console.log('User ID for Analytics:', localStorage.getItem('gb_anonymous_id') || 'Not set');
  console.log('Session ID:', sessionStorage.getItem('gb_session_id') || 'Not set');
  console.log('variant:ready Event Dispatched:', window.GB_EXECUTION?.ready ? 'YES' : 'NO');
  console.log('localStorage backup:', localStorage.getItem('gb_active_tests') || 'Not set');
  console.groupEnd();
};

// Force refresh assignments for pixel (useful for debugging)
window.gbRefreshPixel = function() {
  if (window.GB_EXECUTION?.evaluations) {
    const assignments = {};
    Object.entries(window.GB_EXECUTION.evaluations).forEach(([expId, data]) => {
      if (data.isABTest && data.included) {
        assignments[expId] = {
          experimentId: expId,
          variationId: data.variation,
          included: true,
          exclusion_reason: null,
          bucket: data.bucket,
          source: data.source,
          experiment_name: null,
          hypothesis: null,
          status: 'active'
        };
      }
    });
    
    window.gbTestAssignments = assignments;
    localStorage.setItem('gb_active_tests', JSON.stringify(assignments));
    
    document.dispatchEvent(new CustomEvent('variant:ready', {
      detail: { assignments: assignments }
    }));
    
    console.log('✅ Refreshed pixel assignments:', assignments);
    return assignments;
  } else {
    console.log('❌ No evaluations available yet');
    return null;
  }
};
</script>