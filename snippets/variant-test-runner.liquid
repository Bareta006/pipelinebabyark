<!-- ============================ -->
<!-- V10 GrowthBook + Shopify (FIXED ARCHITECTURE) -->
<!-- ============================ -->

<!-- 0) Anti-flicker: Hide gated elements until experiments are ready -->
<style>
  [data-gb-gate] { visibility: hidden; }
  .gb-ready [data-gb-gate] { visibility: visible; }
</style>

<!-- 1) Configuration -->
<script>
  // ===== REPLACE WITH YOUR VALUES =====
  const GB_CLIENT_KEY = "sdk-Knbwv55oDrfYDuq";  // Your public SDK client key
  const GB_API_HOST = "https://cdn.growthbook.io";
  const GB_ADMIN_KEY = "secret_admin_wnzHrHZzdNquNDZ6KguCj0576F1SU6cpu0eVgGk8JQ"; // Your admin API key
  const GB_API_URL = "https://api.growthbook.io/api/v1";

  // Preview configuration for internal testing
  const PREVIEW_CONFIG = {
    enabled: true,
    patterns: [/^EXP\d+$/, /^exp_\w+$/, /^test_\w+$/]
  };

  // Global config for GrowthBook auto bundle
  window.growthbook_config = {
    enableDevMode: false,
    attributes: {
      isStaff: !!(window.Shopify && (Shopify.designMode || /[?&]staff=1(&|$)/.test(location.search))),
      themeEditor: !!(window.Shopify && Shopify.designMode),
      url: location.href,
      deviceType: /Mobile|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ? 'mobile' : 'desktop',
      currentUrl: location.href,
      path: location.pathname
    },
    trackingCallback: (experiment, result) => {
      if (window.dataLayer) {
        window.dataLayer.push({
          event: "gb_experiment_viewed",
          experimentId: experiment.key,
          variationId: result.key,
          featureId: result.featureId || null
        });
      }
    }
  };
</script>

<!-- 2) GrowthBook auto bundle -->
<script async
  src="https://cdn.jsdelivr.net/npm/@growthbook/growthbook/dist/bundles/auto.min.js"
  data-api-host="%GB_API_HOST%"
  data-client-key="%GB_CLIENT_KEY%"
  data-use-sticky-bucket-service="cookie"
  data-no-auto-cookies>
</script>
<script>
  // Runtime replacement of placeholders
  (function patchDataAttrs() {
    const script = document.currentScript.previousElementSibling;
    if (!script) return;
    if (script.dataset.apiHost === "%GB_API_HOST%") script.dataset.apiHost = GB_API_HOST;
    if (script.dataset.clientKey === "%GB_CLIENT_KEY%") script.dataset.clientKey = GB_CLIENT_KEY;
  })();
</script>

<!-- 3) Simple experiment executor -->
<script>
(function() {
  const previewOverrides = new Map();
  let isExecutorReady = false;

  function debug(message, data) {
    if (/[?&]debug=1(&|$)/.test(location.search)) {
      console.log(`[GB-Executor] ${message}`, data || '');
    }
  }

  // Simple preview system
  function getPreviewExperiments() {
    if (!PREVIEW_CONFIG.enabled) return {};
    
    const urlParams = new URLSearchParams(window.location.search);
    const previews = {};
    
    for (const [key, value] of urlParams) {
      const isExperimentParam = PREVIEW_CONFIG.patterns.some(pattern => pattern.test(key));
      if (isExperimentParam) {
        const variantIndex = parseInt(value);
        if (!isNaN(variantIndex)) {
          previews[key] = variantIndex;
        }
      }
    }
    
    return previews;
  }

  async function fetchPreviewConfig(experimentId) {
    try {
      const featureFlagId = `exp-${experimentId}`;
      const response = await fetch(`${GB_API_URL}/features/${featureFlagId}`, {
        headers: {
          'Authorization': `Bearer ${GB_ADMIN_KEY}`,
          'Content-Type': 'application/json'
        }
      });
      
      if (!response.ok) {
        throw new Error(`Failed to fetch feature flag: ${response.status}`);
      }
      
      const data = await response.json();
      return data.feature;
    } catch (error) {
      debug(`Error fetching preview config for ${experimentId}:`, error);
      return null;
    }
  }

  function extractVariationValue(featureConfig, variantIndex) {
    try {
      const productionRules = featureConfig.environments?.production?.rules || featureConfig.rules || [];
      
      // Look for experiment-ref rule first
      const experimentRule = productionRules.find(rule => rule.type === 'experiment-ref');
      if (experimentRule && experimentRule.variations) {
        if (variantIndex >= experimentRule.variations.length) {
          debug(`Variant index ${variantIndex} out of bounds for experiment-ref`);
          return null;
        }
        return experimentRule.variations[variantIndex].value || '';
      }
      
      // Handle force rules
      const forceRule = productionRules.find(rule => rule.force !== undefined);
      if (forceRule) {
        if (variantIndex === 0) {
          return '';
        } else if (variantIndex === 1) {
          return forceRule.force || '';
        } else {
          debug(`Force rule only supports variants 0 and 1, got ${variantIndex}`);
          return null;
        }
      }
      
      if (variantIndex === 0) {
        return featureConfig.defaultValue || '';
      }
      
      debug('No matching rule found for preview');
      return null;
    } catch (error) {
      debug('Error extracting variation value:', error);
      return null;
    }
  }

  async function applyPreviewOverrides() {
    const previews = getPreviewExperiments();
    if (Object.keys(previews).length === 0) return;
    
    debug(`Preview mode: ${Object.keys(previews).length} overrides`, previews);
    
    for (const [param, variantIndex] of Object.entries(previews)) {
      let experimentId = param;
      
      if (param.startsWith('EXP')) {
        experimentId = param.replace('EXP', '');
      } else if (param.startsWith('test_')) {
        experimentId = param.replace('test_', '');
      } else if (param.startsWith('exp_')) {
        experimentId = param.replace('exp_', '');
      }
      
      const featureConfig = await fetchPreviewConfig(experimentId);
      if (!featureConfig) {
        debug(`Could not fetch config for experiment ${experimentId}`);
        continue;
      }
      
      const featureKey = `exp-${experimentId}`;
      const previewValue = extractVariationValue(featureConfig, variantIndex);
      if (previewValue !== null) {
        previewOverrides.set(featureKey, previewValue);
        debug(`Preview override: ${featureKey} -> variant ${variantIndex}`);
      }
    }
  }

  function executeJavaScript(code, experimentId) {
    if (!code || typeof code !== 'string' || !code.trim()) {
      debug(`No JavaScript code to execute for ${experimentId}`);
      return false;
    }

    debug(`Executing JavaScript for ${experimentId}`, code.substring(0, 100) + '...');
    
    try {
      new Function(code)();
      debug(`Successfully executed ${experimentId}`);
      return true;
    } catch (error) {
      debug(`Error executing ${experimentId}:`, error);
      return false;
    }
  }

  function runExperiments() {
    debug('Running experiment evaluation...');
    
    const gb = window.growthbook || window._growthbook;
    if (!gb || !gb.ready) {
      debug('GrowthBook not ready, will retry...');
      return;
    }

    let experimentsExecuted = 0;

    // Apply preview overrides first
    for (const [featureKey, previewValue] of previewOverrides) {
      if (executeJavaScript(previewValue, `${featureKey} (preview)`)) {
        experimentsExecuted++;
      }
    }

    // Get all experiments from GrowthBook
    const features = gb.getFeatures();
    const experiments = Object.keys(features).filter(key => key.startsWith('exp-'));

    debug(`Found ${experiments.length} total experiments`);

    for (const experimentKey of experiments) {
      // Skip if we have a preview override
      if (previewOverrides.has(experimentKey)) {
        debug(`Skipping ${experimentKey} - preview override exists`);
        continue;
      }

      const result = gb.evalFeature(experimentKey);
      debug(`${experimentKey} evaluation:`, {
        hasValue: !!result?.value,
        valueLength: result?.value?.length || 0,
        source: result?.source,
        inExperiment: result?.inExperiment
      });

      if (result?.value && result.value.trim()) {
        if (executeJavaScript(result.value, experimentKey)) {
          experimentsExecuted++;
        }
      }
    }

    debug(`Executed ${experimentsExecuted} experiments`);
    
    // Always reveal content
    document.documentElement.classList.add("gb-ready");
    
    // Store assignments for tracking
    storeAssignments(gb, experiments);
  }

  function storeAssignments(gb, experiments) {
  const assignments = {};
  const features = gb.getFeatures();
  
  for (const key of experiments) {
    const result = gb.evalFeature(key);
    const feature = features[key];
    const cleanId = key.replace(/^exp-/, '');
    
    // Determine if experiment is disabled (draft)
    const isDisabled = !feature.rules || feature.rules.length === 0;
    
    // Determine exclusion reason
    let exclusionReason = null;
    if (isDisabled) {
      exclusionReason = 'experiment_disabled';
    } else if (!result.inExperiment) {
      exclusionReason = 'traffic_allocation'; // Could be targeting or traffic
    }
    
    assignments[cleanId] = {
      included: result.inExperiment || false,
      variationId: result.inExperiment ? result.variationId : null,
      exclusion_reason: exclusionReason,
      experiment_name: feature.rules?.[0]?.name || null, // Get actual name
      hypothesis: null,
      status: isDisabled ? 'draft' : 'active'
    };
  }
  
  window.gbTestAssignments = assignments;
  
  try {
    localStorage.setItem('gb_active_tests', JSON.stringify(assignments));
  } catch (e) { /* ignore */ }
  
  document.dispatchEvent(new CustomEvent('variant:ready', {
    detail: { assignments, timestamp: new Date().toISOString() }
  }));
}

  // Initialize when GrowthBook is ready
  async function initialize() {
    if (isExecutorReady) {
      debug('Executor already initialized');
      return;
    }

    debug('Initializing experiment executor...');
    isExecutorReady = true;

    // Apply preview overrides
    await applyPreviewOverrides();

    // Run experiments immediately
    runExperiments();

    // Set up section reload handler for Shopify
    document.addEventListener("shopify:section:load", function() {
      debug('Shopify section reloaded, re-running experiments...');
      runExperiments();
    });
  }

  // Multiple initialization strategies
  
  // Strategy 1: GrowthBook queue (primary)
  window.growthbook_queue = window.growthbook_queue || [];
  window.growthbook_queue.push(function(gb) {
    debug('GrowthBook queue callback triggered');
    setTimeout(initialize, 50); // Small delay to ensure data is loaded
  });

  // Strategy 2: Poll for GrowthBook readiness
  let pollAttempts = 0;
  const maxPollAttempts = 100; // 10 seconds max
  
  function pollForGrowthBook() {
    pollAttempts++;
    const gb = window.growthbook || window._growthbook;
    
    if (gb && gb.ready && !isExecutorReady) {
      debug(`GrowthBook ready detected on poll attempt ${pollAttempts}`);
      initialize();
      return;
    }
    
    if (pollAttempts < maxPollAttempts) {
      setTimeout(pollForGrowthBook, 100);
    } else {
      debug('Max poll attempts reached, GrowthBook may not be loading');
    }
  }

  // Strategy 3: DOM ready fallback
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(pollForGrowthBook, 500);
    });
  } else {
    setTimeout(pollForGrowthBook, 500);
  }

  // Strategy 4: Window load fallback
  window.addEventListener('load', function() {
    if (!isExecutorReady) {
      debug('Window load fallback triggered');
      setTimeout(initialize, 1000);
    }
  });

  // Debug helper
  window.gbDebug = function() {
    console.group('GrowthBook Experiment Executor Debug');
    const gb = window.growthbook || window._growthbook;
    
    console.log('Executor ready:', isExecutorReady);
    console.log('GrowthBook instance:', !!gb);
    console.log('GrowthBook ready:', gb?.ready);
    console.log('Preview overrides:', Array.from(previewOverrides.keys()));
    
    if (gb) {
      const features = gb.getFeatures();
      const experiments = Object.keys(features).filter(k => k.startsWith('exp-'));
      console.log('Available experiments:', experiments);
      
      experiments.forEach(key => {
        const result = gb.evalFeature(key);
        console.log(`${key}:`, {
          hasValue: !!result?.value,
          valueLength: result?.value?.length || 0,
          source: result.source
        });
      });
    }
    
    console.groupEnd();
  };

  // Manual re-run helper
  window.gbRunExperiments = function() {
    console.log('Manually running experiments...');
    runExperiments();
  };

  debug('Experiment executor script loaded');
})();
</script>

<!-- 4) Usage Examples -->
<!--
Gate content that should be hidden during loading:
<div data-gb-gate>This content will be hidden until experiments load</div>

Preview URLs:
?EXP505=1     (force experiment 505, variant 1)  
?test_home=0  (force home experiment, control)

Debug mode:
?debug=1      (enable debug logging)

Manual helpers:
gbDebug()           (show debug info)
gbRunExperiments()  (manually re-run experiments)
-->>