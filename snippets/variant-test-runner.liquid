<!-- Complete GrowthBook and Analytics Pixel Integration for Theme.liquid -->
<!-- Place this entire block in your theme.liquid file, preferably in the <head> section -->
<script>
// Force load Shopify analytics if not present
if (!window.analytics) {
  window.analytics = {
    subscribe: function(event, callback) {
      // Basic polyfill - wait for real analytics to load
      console.log('[Analytics Polyfill] Queuing subscription for:', event);
      window._analyticsQueue = window._analyticsQueue || [];
      window._analyticsQueue.push({event: event, callback: callback});
    }
  };
}
</script>

<!-- Anti-flicker styles for GrowthBook -->
<style>
  [data-gb-gate] {
    visibility: hidden;
    transition: visibility 0.2s ease-in-out;
  }
  .gb-ready [data-gb-gate] {
    visibility: visible;
  }
  .gb-timeout [data-gb-gate] {
    visibility: visible;
  }
</style>

<!-- ============================================ -->
<!-- GROWTHBOOK SCRIPT - MUST LOAD FIRST -->
<!-- ============================================ -->
<script>
// ============================================
// STABLE USER ID & CONFIGURATION
// ============================================
(function() {
  'use strict';
  
  // Get or create stable user ID (shared with pixel)
  const USER_ID_KEY = 'gb_anonymous_id'; // Matches pixel's expectation
  let stableUserId = localStorage.getItem(USER_ID_KEY);
  
  if (!stableUserId) {
    stableUserId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    localStorage.setItem(USER_ID_KEY, stableUserId);
    console.log('[GB] Created new stable user ID:', stableUserId);
  } else {
    console.log('[GB] Using existing stable user ID:', stableUserId);
  }
  
  // Also store as gb_stable_user_id for backward compatibility
  localStorage.setItem('gb_stable_user_id', stableUserId);
  
  // Store globally for debugging
  window.GB_STABLE_USER_ID = stableUserId;
  
  // Configuration for preview system
  window.GB_PREVIEW_CONFIG = {
    enabled: true,
    patterns: [/^EXP\d+$/, /^exp_\w+$/, /^test_\w+$/],
    overrides: new Map()
  };
  
  // Pre-configure GrowthBook with stable ID
  window.growthbook_config = {
    apiHost: "https://cdn.growthbook.io",
    clientKey: "sdk-Knbwv55oDrfYDuq",
    enableDevMode: /[?&]debug=1(&|$)/.test(location.search),
    
    attributes: {
      id: stableUserId, // Our stable ID
      
      // Shopify attributes
      customerId: window.ShopifyAnalytics?.meta?.page?.customerId || null,
      pageType: window.ShopifyAnalytics?.meta?.page?.pageType || 'unknown',
      
      // Device detection  
      deviceType: /Mobile|Android|iPhone|iPad/i.test(navigator.userAgent) ? 'mobile' : 'desktop',
      browser: (function() {
        const ua = navigator.userAgent;
        if (ua.includes('Chrome') && !ua.includes('Edge')) return 'chrome';
        if (ua.includes('Safari') && !ua.includes('Chrome')) return 'safari';  
        if (ua.includes('Firefox')) return 'firefox';
        if (ua.includes('Edge')) return 'edge';
        return 'other';
      })(),
      
      // Page attributes
      url: location.href,
      path: location.pathname,
      domain: location.hostname
    },
    
    trackingCallback: function(experiment, result) {
      const debug = /[?&]debug=1(&|$)/.test(location.search);
      if (debug) {
        console.log('[GB] Experiment viewed:', experiment.key, {
          variation: result.variationId,
          bucket: result.experimentResult?.bucket
        });
      }
      
      // Analytics tracking
      if (window.dataLayer) {
        window.dataLayer.push({
          event: 'gb_experiment_viewed',
          experimentId: experiment.key,
          variationId: result.variationId
        });
      }
    }
  };
})();

// Load GrowthBook auto-bundle
(function() {
  const script = document.createElement('script');
  script.async = true;
  script.src = 'https://cdn.jsdelivr.net/npm/@growthbook/growthbook/dist/bundles/auto.min.js';
  script.dataset.apiHost = 'https://cdn.growthbook.io';
  script.dataset.clientKey = 'sdk-Knbwv55oDrfYDuq';
  document.head.appendChild(script);
})();

// ============================================  
// EXPERIMENT HANDLER WITH EARLY LOCALSTORAGE WRITE
// ============================================
(function() {
  const DEBUG = /[?&]debug=1(&|$)/.test(location.search);
  
  // Track execution state
  window.GB_EXECUTION = {
    ready: false,
    executed: new Set(),
    evaluations: {},
    previews: new Map()
  };
  
  // Initialize gbTestAssignments immediately as empty
  window.gbTestAssignments = {};
  
  // Check for preview experiments in URL
  function getPreviewExperiments() {
    if (!window.GB_PREVIEW_CONFIG?.enabled) return {};
    
    const urlParams = new URLSearchParams(window.location.search);
    const previews = {};
    
    for (const [key, value] of urlParams) {
      const isExperimentParam = window.GB_PREVIEW_CONFIG.patterns.some(pattern => pattern.test(key));
      if (isExperimentParam) {
        const variantIndex = parseInt(value);
        if (!isNaN(variantIndex)) {
          previews[key] = variantIndex;
        }
      }
    }
    
    return previews;
  }
  
  // Apply preview overrides after normal execution
  async function applyPreviewOverrides(gb) {
    const previews = getPreviewExperiments();
    if (Object.keys(previews).length === 0) return;
    
    console.log('[GB] Preview mode enabled:', previews);
    
    // Get all features to check variations
    const features = gb.getFeatures();
    
    for (const [param, variantIndex] of Object.entries(previews)) {
      let experimentKey = `exp-${param}`;
      
      // Handle different naming formats
      if (param.startsWith('EXP')) {
        experimentKey = `exp-${param}`;
      } else if (param.startsWith('test_')) {
        experimentKey = `exp-${param.replace('test_', '')}`;
      } else if (param.startsWith('exp_')) {
        experimentKey = `exp-${param.replace('exp_', '')}`;
      }
      
      // Check if experiment exists
      const feature = features[experimentKey];
      if (!feature) {
        console.warn(`[GB] Preview experiment ${experimentKey} not found`);
        continue;
      }
      
      // Find the rule with variations
      let previewCode = '';
      if (feature.rules && feature.rules.length > 0) {
        for (const rule of feature.rules) {
          if (rule.variations && variantIndex < rule.variations.length) {
            previewCode = rule.variations[variantIndex] || '';
            break;
          }
        }
      }
      
      // If we found code for this variant, execute it
      if (previewCode && typeof previewCode === 'string' && previewCode.trim()) {
        try {
          // First, clear any previously executed version of this experiment
          const experimentId = experimentKey.replace('exp-', '');
          if (window.GB_EXECUTION.executed.has(experimentId)) {
            console.log(`[GB] Preview: Overriding previously executed ${experimentId}`);
          }
          
          new Function(previewCode)();
          window.GB_EXECUTION.previews.set(experimentId, variantIndex);
          console.log(`[GB] âœ… Preview executed: ${experimentId} variant ${variantIndex}`);
        } catch (error) {
          console.error(`[GB] Preview execution failed for ${experimentKey}:`, error);
        }
      } else {
        console.log(`[GB] Preview: No code for ${experimentKey} variant ${variantIndex}`);
      }
    }
  }
  
  // Wait for GrowthBook and execute experiments
  window.growthbook_queue = window.growthbook_queue || [];
  window.growthbook_queue.push(async function(gb) {
    console.log('[GB] Auto-bundle initialized');
    
    // Verify our stable ID is being used
    const currentId = gb.getAttributes()?.id;
    if (currentId !== window.GB_STABLE_USER_ID) {
      console.warn('[GB] Fixing ID from', currentId, 'to', window.GB_STABLE_USER_ID);
      gb.setAttributes({
        ...gb.getAttributes(),
        id: window.GB_STABLE_USER_ID
      });
    }
    
    // Function to execute experiments
    async function executeExperiments() {
      // Ensure features are loaded
      if (!gb.ready) {
        console.log('[GB] Waiting for features...');
        await gb.loadFeatures();
      }
      
      const features = gb.getFeatures();
      const experiments = Object.keys(features).filter(k => k.startsWith('exp-'));
      
      console.log('[GB] Processing', experiments.length, 'experiments');
      
      // EARLY EVALUATION PASS - Just evaluate, don't execute yet
      // This ensures assignments are ready ASAP for the pixel
      const earlyAssignments = {};
      
      experiments.forEach(key => {
        const experimentId = key.replace('exp-', '');
        const result = gb.evalFeature(key);
        const feature = features[key];
        const rule = feature?.rules?.[0];
        
        // Determine if this is a real A/B test
        const isABTest = rule?.variations && rule?.force === undefined;
        
        // Only store A/B tests that user is included in
        if (isABTest && result?.experimentResult?.inExperiment) {
          earlyAssignments[experimentId] = {
            experimentId: experimentId,
            variationId: result.experimentResult.variationId,
            included: true,
            exclusion_reason: null,
            bucket: result.experimentResult.bucket,
            source: result.source,
            experiment_name: null,
            hypothesis: null,
            status: 'active'
          };
        }
      });
      
      // IMMEDIATELY write to localStorage and window before any other processing
      try {
        localStorage.setItem('gb_active_tests', JSON.stringify(earlyAssignments));
        window.gbTestAssignments = earlyAssignments;
        console.log(`[GB] Early write: ${Object.keys(earlyAssignments).length} A/B tests written to localStorage and window`);
      } catch (e) {
        console.warn('[GB] Could not write early assignments to localStorage:', e);
      }
      
      // Now continue with normal processing
      let executedCount = 0;
      let includedCount = 0;
      
      // Helper function to check condition matching
      function matchesCondition(attributes, condition) {
        // Simplified condition checking - you might need to expand this
        for (const [key, value] of Object.entries(condition)) {
          if (key === '$and') {
            return value.every(subCondition => matchesCondition(attributes, subCondition));
          }
          if (key === '$or') {
            return value.some(subCondition => matchesCondition(attributes, subCondition));
          }
          if (typeof value === 'object' && value !== null && value.$regex) {
            const regex = new RegExp(value.$regex);
            return regex.test(attributes[key]);
          }
          if (attributes[key] !== value) {
            return false;
          }
        }
        return true;
      }
      
      experiments.forEach(key => {
        const experimentId = key.replace('exp-', '');
        const result = gb.evalFeature(key);
        const feature = features[key];
        const rule = feature?.rules?.[0];
        
        // Determine if this is a real A/B test (not a force rule or disabled)
        const isABTest = rule?.variations && rule?.force === undefined;
        const isForceRule = rule?.force !== undefined;
        const isDisabled = !feature?.rules || feature.rules.length === 0;
        
        // Store evaluation details
        window.GB_EXECUTION.evaluations[experimentId] = {
          included: result?.experimentResult?.inExperiment || false,
          variation: result?.experimentResult?.variationId,
          bucket: result?.experimentResult?.bucket,
          value: result?.value,
          source: result?.source,
          reason: result?.experimentResult?.reason || null,
          isABTest: isABTest,
          isForceRule: isForceRule,
          isDisabled: isDisabled
        };
        
        // Enhanced debug logging for ALL experiments
        if (DEBUG) {
          // Determine experiment type and status
          let status = '';
          let details = {};
          
          if (isDisabled) {
            status = 'âš ï¸ DISABLED/DRAFT';
            details = { reason: 'No rules configured' };
          } else if (isForceRule) {
            status = 'ðŸ”§ FORCE RULE';
            details = {
              hasCode: !!rule.force,
              targeting: rule.condition || 'none'
            };
          } else if (isABTest) {
            status = result?.experimentResult?.inExperiment ? 'âœ… A/B INCLUDED' : 'âŒ A/B EXCLUDED';
            details = {
              variation: result?.experimentResult?.variationId,
              bucket: result?.experimentResult?.bucket?.toFixed(4),
              coverage: (rule.coverage || 1) * 100 + '%',
              targeting: rule.condition || 'none',
              source: result?.source
            };
            
            // Add exclusion reason if not included
            if (!result?.experimentResult?.inExperiment) {
              // Check targeting mismatch
              if (rule.condition && !matchesCondition(gb.getAttributes(), rule.condition)) {
                details.exclusionReason = 'targeting_mismatch';
              } else if (result?.experimentResult?.bucket > (rule.coverage || 1)) {
                details.exclusionReason = 'outside_coverage';
              } else {
                details.exclusionReason = result?.experimentResult?.reason || 'unknown';
              }
            }
          }
          
          console.log(`[GB] ${experimentId} ${status}:`, details);
        }
        
        // Track if included in A/B test
        if (result?.experimentResult?.inExperiment) {
          includedCount++;
        }
        
        // Execute JavaScript if present
        if (result?.value && typeof result.value === 'string' && result.value.trim()) {
          // Skip if already executed
          if (window.GB_EXECUTION.executed.has(experimentId)) {
            if (DEBUG) console.log(`[GB] ${experimentId} already executed, skipping`);
            return;
          }
          
          try {
            new Function(result.value)();
            window.GB_EXECUTION.executed.add(experimentId);
            executedCount++;
            
            if (DEBUG) {
              console.log(`[GB] ðŸš€ ${experimentId} EXECUTED`);
            }
          } catch (error) {
            console.error(`[GB] ðŸ’¥ ${experimentId} EXECUTION FAILED:`, error.message);
          }
        }
      });
      
      console.log(`[GB] Complete: ${includedCount} included, ${executedCount} executed`);
      
      // Final update of assignments (in case anything changed during execution)
      const finalAssignments = {};
      Object.entries(window.GB_EXECUTION.evaluations).forEach(([expId, data]) => {
        if (data.isABTest && data.included) {
          finalAssignments[expId] = {
            experimentId: expId,
            variationId: data.variation,
            included: true,
            exclusion_reason: null,
            bucket: data.bucket,
            source: data.source,
            experiment_name: null,
            hypothesis: null,
            status: 'active'
          };
        }
      });
      
      // Update if changed
      if (JSON.stringify(finalAssignments) !== JSON.stringify(earlyAssignments)) {
        window.gbTestAssignments = finalAssignments;
        try {
          localStorage.setItem('gb_active_tests', JSON.stringify(finalAssignments));
          console.log('[GB] Updated assignments after execution');
        } catch (e) {
          console.warn('[GB] Could not update localStorage:', e);
        }
      }
      
      console.log(`[GB] Analytics: Reporting ${Object.keys(window.gbTestAssignments).length} included A/B tests to pixel`);
      if (DEBUG && Object.keys(window.gbTestAssignments).length > 0) {
        console.log('[GB] Assignments ready for pixel:', window.gbTestAssignments);
      }
      
      // After normal execution, apply preview overrides
      await applyPreviewOverrides(gb);
      
      window.GB_EXECUTION.ready = true;
      document.documentElement.classList.add('gb-ready');
    }
    
    // Execute on load
    await executeExperiments();
    
    // Re-execute on Shopify section changes
    document.addEventListener('shopify:section:load', function() {
      console.log('[GB] Section reload detected');
      window.GB_EXECUTION.executed.clear(); // Allow re-execution
      executeExperiments();
    });
    
    // Safe attribute updates for cart events  
    function updateAttributes(newAttrs) {
      gb.setAttributes({
        ...gb.getAttributes(),
        ...newAttrs,
        id: window.GB_STABLE_USER_ID // Never change ID
      });
    }
    
    document.addEventListener('cart:updated', function() {
      updateAttributes({
        cartUpdated: Date.now(),
        cartItemCount: window.Shopify?.cart?.item_count || 0
      });
    });
    
    // Monitor ID stability
    setInterval(function() {
      const currentId = gb.getAttributes()?.id;
      if (currentId !== window.GB_STABLE_USER_ID) {
        console.error('[GB] ID drift detected! Fixing...');
        gb.setAttributes({
          ...gb.getAttributes(),
          id: window.GB_STABLE_USER_ID
        });
      }
    }, 5000);
    
    // Store reference
    window.gb = gb;
  });
})();

// ============================================
// DEBUG UTILITIES  
// ============================================
window.gbDebug = function() {
  const gb = window.gb || window._growthbook;
  
  console.group('ðŸ”¬ GrowthBook Debug');
  console.log('Stable ID:', window.GB_STABLE_USER_ID);
  console.log('Current ID:', gb?.getAttributes()?.id);
  console.log('Match:', gb?.getAttributes()?.id === window.GB_STABLE_USER_ID ? 'âœ…' : 'âŒ');
  
  if (window.GB_EXECUTION.evaluations) {
    const abTests = Object.entries(window.GB_EXECUTION.evaluations).filter(([_, data]) => data.isABTest);
    const forceRules = Object.entries(window.GB_EXECUTION.evaluations).filter(([_, data]) => data.isForceRule);
    const disabled = Object.entries(window.GB_EXECUTION.evaluations).filter(([_, data]) => data.isDisabled);
    
    console.group('A/B Tests');
    abTests.forEach(([id, data]) => {
      const status = data.included ? 'âœ… INCLUDED' : 'âŒ EXCLUDED';
      const executed = window.GB_EXECUTION.executed.has(id) ? 'ðŸš€' : '';
      console.log(`${status} ${id}: Var ${data.variation}, Bucket ${data.bucket?.toFixed(4)} ${executed}`);
    });
    console.groupEnd();
    
    console.group('Force Rules (Feature Flags)');
    forceRules.forEach(([id, data]) => {
      const executed = window.GB_EXECUTION.executed.has(id) ? 'ðŸš€ EXECUTED' : 'â­• NOT EXECUTED';
      console.log(`${id}: ${executed}`);
    });
    console.groupEnd();
    
    if (disabled.length > 0) {
      console.group('Disabled/Draft');
      disabled.forEach(([id]) => console.log(`âš ï¸ ${id}`));
      console.groupEnd();
    }
  }
  
  console.log('Attributes:', gb?.getAttributes());
  console.log('Analytics Assignments:', window.gbTestAssignments);
  console.log('localStorage gb_active_tests:', localStorage.getItem('gb_active_tests'));
  console.groupEnd();
  
  return {
    stableId: window.GB_STABLE_USER_ID,
    currentId: gb?.getAttributes()?.id,
    evaluations: window.GB_EXECUTION.evaluations,
    analyticsAssignments: window.gbTestAssignments
  };
};

window.gbTestBucket = function(experimentId) {
  const gb = window.gb || window._growthbook;
  const key = experimentId.startsWith('exp-') ? experimentId : `exp-${experimentId}`;
  const result = gb?.evalFeature(key);
  
  console.log(`${experimentId}:`, {
    included: result?.experimentResult?.inExperiment,
    variation: result?.experimentResult?.variationId,  
    bucket: result?.experimentResult?.bucket
  });
  
  return result?.experimentResult?.bucket;
};

window.gbAnalyze = function(experimentId) {
  const gb = window.gb || window._growthbook;
  const key = experimentId.startsWith('exp-') ? experimentId : `exp-${experimentId}`;
  const feature = gb?.getFeatures()?.[key];
  const result = gb?.evalFeature(key);
  const rule = feature?.rules?.[0];
  
  console.group(`ðŸ” Analysis: ${experimentId}`);
  
  if (!feature) {
    console.log('âŒ Experiment not found');
  } else if (!rule) {
    console.log('âš ï¸ No rules configured (draft/disabled)');
  } else {
    console.log('Rule Type:', rule.force !== undefined ? 'Force Rule' : 'A/B Test');
    console.log('Targeting:', rule.condition || 'none');
    
    if (rule.variations) {
      console.log('Coverage:', (rule.coverage || 1) * 100 + '%');
      console.log('Variations:', rule.variations.length);
      console.log('Weights:', rule.weights);
    }
    
    console.log('Your Attributes:', gb.getAttributes());
    console.log('Evaluation Result:', {
      included: result?.experimentResult?.inExperiment,
      variation: result?.experimentResult?.variationId,
      bucket: result?.experimentResult?.bucket,
      source: result?.source
    });
    
    if (rule.condition) {
      console.log('Targeting Match:', 
        Object.entries(rule.condition).map(([k,v]) => {
          const attrValue = gb.getAttributes()[k];
          if (v && typeof v === 'object' && v.$regex) {
            const regex = new RegExp(v.$regex);
            return `${k}: "${attrValue}" matches ${v.$regex}? ${regex.test(attrValue)}`;
          }
          return `${k}: "${attrValue}" === ${JSON.stringify(v)}? ${attrValue === v}`;
        })
      );
    }
    
    console.log('Will report to analytics?', 
      rule.force === undefined && result?.experimentResult?.inExperiment ? 
      'âœ… YES - A/B test with inclusion' : 
      'âŒ NO - Force rule, disabled, or excluded from A/B test'
    );
  }
  
  console.groupEnd();
};

window.gbPixelStatus = function() {
  console.group('ðŸ“Š Pixel Integration Status');
  console.log('Test Assignments Available:', window.gbTestAssignments ? 'YES' : 'NO');
  
  if (window.gbTestAssignments) {
    const count = Object.keys(window.gbTestAssignments).length;
    console.log(`Reporting ${count} A/B test${count !== 1 ? 's' : ''} to analytics`);
    
    if (count > 0) {
      console.group('A/B Tests Being Tracked:');
      Object.entries(window.gbTestAssignments).forEach(([id, data]) => {
        console.log(`${id}: Variant ${data.variationId} (bucket: ${data.bucket?.toFixed(4)})`);
      });
      console.groupEnd();
    }
  }
  
  console.log('User ID for Analytics:', localStorage.getItem('gb_anonymous_id') || 'Not set');
  console.log('localStorage gb_active_tests:', localStorage.getItem('gb_active_tests') || 'Not set');
  console.log('GrowthBook Ready:', window.GB_EXECUTION?.ready ? 'YES' : 'NO');
  console.groupEnd();
};
</script>

<!-- ============================================ -->
<!-- VARIANT ANALYTICS PIXEL - LOADS AFTER GROWTHBOOK -->
<!-- ============================================ -->
<script>
// variant-analytics-pixel.js
// Variant Analytics Pixel v9.0 - Direct Integration (No Sandbox)
(function() {
 'use strict';
 
 // ===== CONFIGURATION - EDIT THESE VALUES =====
 const SHOP_ID = '0527f1ac-fabe-4afb-b72c-bff74d3366ae';  
 const API_KEY = '96777694e1acbb3f593a2be3f597904375e5e8d97efa587e753978f7f1a6fc04'; 
 const ANALYTICS_ENDPOINT = 'https://sessions-db-api.vercel.app/api/events_growth_book';
 const DEBUG = true;  // Set to true for debugging
 // ============================================
 
 // Advanced Configuration
 const PIXEL_VERSION = '9.0.0';  // Major version: moved outside sandbox
 
 // Helper Functions
 function log(...args) {
   if (DEBUG) console.log('[Variant Pixel]', ...args);
 }
 
 function generateUUID() {
   return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
     const r = Math.random() * 16 | 0;
     const v = c === 'x' ? r : (r & 0x3 | 0x8);
     return v.toString(16);
   });
 }
 
 // Storage management - now with direct localStorage access
 const storage = {
   getUserId() {
     // Use the same ID as GrowthBook for consistency
     let userId = localStorage.getItem('gb_anonymous_id');
     
     if (!userId) {
       userId = generateUUID();
       localStorage.setItem('gb_anonymous_id', userId);
     }
     
     return userId;
   },
   
   getSessionId() {
     let sessionId = sessionStorage.getItem('gb_session_id');
     
     if (!sessionId) {
       sessionId = generateUUID();
       sessionStorage.setItem('gb_session_id', sessionId);
     }
     
     return sessionId;
   }
 };
 
 /**
  * Get experiment assignments directly from window object
  * No need for polling or delays since we're in the same context
  */
 function getExperimentAssignments() {
   // Direct access to window.gbTestAssignments
   const assignments = window.gbTestAssignments || {};
   
   // Filter to only include active experiments (not disabled)
   const filteredAssignments = {};
   
   Object.entries(assignments).forEach(([expId, assignment]) => {
     // Only include experiments that are NOT disabled and are included
     if (assignment.status === 'active' && assignment.included === true) {
       filteredAssignments[expId] = {
         ...assignment,
         experimentId: expId,
         experiment_name: assignment.experiment_name || null,
         hypothesis: assignment.hypothesis || null,
         status: assignment.status || 'active'
       };
     }
   });
   
   if (DEBUG) {
     const totalCount = Object.keys(assignments).length;
     const activeCount = Object.keys(filteredAssignments).length;
     
     if (totalCount > 0) {
       log(`Found ${totalCount} total experiments, ${activeCount} active and included`);
     }
   }
   
   return filteredAssignments;
 }
 
 // Main tracking function
 function trackEvent(eventType, eventName, eventData = {}) {
   const experiments = getExperimentAssignments();
   
   // Log summary of experiment assignments
   if (DEBUG) {
     const count = Object.keys(experiments).length;
     log(`Tracking ${eventName} with ${count} active experiments`);
   }
   
   const deviceInfo = {
     userAgent: navigator.userAgent,
     platform: navigator.platform,
     screenWidth: window.screen.width,
     screenHeight: window.screen.height,
     viewportWidth: window.innerWidth || 0,
     viewportHeight: window.innerHeight || 0,
     isMobile: /Mobile|Android|iPhone|iPad/i.test(navigator.userAgent)
   };
   
   const payload = {
     type: eventType,
     data: {
       event_name: eventName,
       session_id: storage.getSessionId(),
       user_id: storage.getUserId(),
       client_timestamp: new Date().toISOString(),
       timezone_offset: new Date().getTimezoneOffset(),
       pixel_version: PIXEL_VERSION,
       shop_domain: window.Shopify?.shop || window.location.hostname,
       device_info: deviceInfo,
       event_data: {
         ...eventData,
         device: deviceInfo,
         test_assignments: experiments,
         experiment_summary: {
           total_experiments: Object.keys(experiments).length,
           included_count: Object.keys(experiments).length, // All are included since we filter
           excluded_count: 0,
           exclusion_reasons: {}
         }
       }
     }
   };
   
   log('Sending event:', eventName, 'Experiments:', Object.keys(experiments));
   
   // Send event
   fetch(ANALYTICS_ENDPOINT, {
     method: 'POST',
     headers: {
       'Content-Type': 'application/json',
       'X-Shop-ID': SHOP_ID,
       'x-api-key': API_KEY
     },
     body: JSON.stringify(payload),
     keepalive: true
   })
   .then(response => {
     if (!response.ok) {
       throw new Error(`HTTP ${response.status}`);
     }
     log('Event sent successfully:', eventName);
     return response.text();
   })
   .then(text => {
     if (DEBUG) log('Response:', text);
   })
   .catch(error => {
     console.error('[Variant Pixel] Error sending event:', error);
   });
 }
 
 // Wait for both analytics and GrowthBook to be ready
 function initializePixel() {
   // Check if analytics.subscribe is available
   if (!window.analytics || !window.analytics.subscribe) {
     log('Waiting for analytics API...');
     setTimeout(initializePixel, 100);
     return;
   }
   
   // Check if GrowthBook has executed (optional - we can work without it)
   if (!window.GB_EXECUTION || !window.GB_EXECUTION.ready) {
     log('GrowthBook not ready yet, but continuing anyway');
     // Don't wait - experiments might not be on this page
   }
   
   log('Initializing pixel with Customer Events API');
   
   // Store page load time
   window.pageLoadTime = Date.now();
   
   // Page View
   analytics.subscribe('page_viewed', (event) => {
     log('Page viewed event received');
     
     trackEvent('navigation', 'page_view', {
       path: event.context.document.location.pathname,
       url: event.context.document.location.href,
       title: event.context.document.title,
       referrer: event.context.document.referrer,
       search_params: event.context.document.location.search,
       page_event_id: generateUUID(),
       template: window.Shopify?.pageType || 'unknown'
     });
   });
   
   // Product View
   analytics.subscribe('product_viewed', (event) => {
     log('Product viewed event received');
     
     trackEvent('product', 'product_view', {
       product: {
         id: event.data?.productVariant?.product?.id,
         title: event.data?.productVariant?.product?.title,
         variant_id: event.data?.productVariant?.id,
         price: event.data?.productVariant?.price?.amount,
         currency: event.data?.productVariant?.price?.currencyCode
       }
     });
   });
   
   // Add to Cart
   analytics.subscribe('product_added_to_cart', (event) => {
     log('Product added to cart event received');
     
     trackEvent('cart', 'add_to_cart', {
       cart_line: {
         price: event.data?.cartLine?.merchandise?.price?.amount,
         currency: event.data?.cartLine?.merchandise?.price?.currencyCode,
         quantity: event.data?.cartLine?.quantity,
         variant_id: event.data?.cartLine?.merchandise?.id
       },
       product_id: event.data?.cartLine?.merchandise?.product?.id,
       product_title: event.data?.cartLine?.merchandise?.product?.title
     });
   });
   
   // Cart Viewed
   analytics.subscribe('cart_viewed', (event) => {
     log('Cart viewed event received');
     
     trackEvent('cart', 'cart_viewed', {
       total: event.data?.cart?.cost?.totalAmount?.amount,
       currency: event.data?.cart?.cost?.totalAmount?.currencyCode,
       item_count: event.data?.cart?.lines?.length || 0
     });
   });
   
   // Checkout Started
   analytics.subscribe('checkout_started', (event) => {
     log('Checkout started event received');
     
     trackEvent('checkout', 'begin_checkout', {
       checkout: {
         total: event.data?.checkout?.totalPrice?.amount,
         currency: event.data?.checkout?.totalPrice?.currencyCode,
         itemCount: event.data?.checkout?.lineItems?.length || 0
       }
     });
   });
   
   // Purchase/Checkout Completed
   analytics.subscribe('checkout_completed', (event) => {
     log('Checkout completed event received');
     
     trackEvent('conversion', 'purchase', {
       order: {
         id: event.data?.checkout?.order?.id,
         total: event.data?.checkout?.totalPrice?.amount,
         currency: event.data?.checkout?.totalPrice?.currencyCode,
         itemCount: event.data?.checkout?.lineItems?.length || 0
       }
     });
   });
   
   log('Customer Events subscriptions registered');
 }
 
 // Debug utilities
 window.debugVariantPixel = function() {
   const assignments = getExperimentAssignments();
   
   console.group('[Variant Pixel] Debug Info:');
   console.log('- Version:', PIXEL_VERSION);
   console.log('- Shop ID:', SHOP_ID);
   console.log('- API Endpoint:', ANALYTICS_ENDPOINT);
   console.log('- User ID:', storage.getUserId());
   console.log('- Session ID:', storage.getSessionId());
   console.log('- GrowthBook Ready:', window.GB_EXECUTION?.ready || false);
   console.log('- Active Experiments:', Object.keys(assignments).length);
   
   if (Object.keys(assignments).length > 0) {
     console.group('Active Experiments:');
     Object.entries(assignments).forEach(([id, exp]) => {
       console.log(`${id}: variant ${exp.variationId} (bucket: ${exp.bucket?.toFixed(4)})`);
     });
     console.groupEnd();
   }
   
   // Check what's available
   console.group('Data Sources:');
   console.log('- window.gbTestAssignments:', window.gbTestAssignments ? Object.keys(window.gbTestAssignments).length + ' experiments' : 'Not set');
   console.log('- localStorage gb_active_tests:', localStorage.getItem('gb_active_tests') ? 'Set' : 'Not set');
   console.log('- Analytics API:', window.analytics?.subscribe ? 'Available' : 'Not available');
   console.groupEnd();
   
   console.log('- Full Assignments:', assignments);
   console.groupEnd();
   
   return assignments;
 };
 
 // Quick status check
 window.pixelStatus = function() {
   const experiments = getExperimentAssignments();
   const status = {
     ready: true,
     experimentsFound: Object.keys(experiments).length,
     userId: storage.getUserId(),
     sessionId: storage.getSessionId()
   };
   console.table(status);
   return status;
 };
 
 // Initialize
 log('Pixel v' + PIXEL_VERSION + ' loading (non-sandboxed)');
 log('Running in main page context with direct access to GrowthBook data');
 
 // Start initialization
 if (document.readyState === 'loading') {
   document.addEventListener('DOMContentLoaded', initializePixel);
 } else {
   // DOM already loaded, initialize immediately
   initializePixel();
 }
 
})();
</script>