{% comment %} /snippets/bundle-debug.liquid - FIXED VARIANT MAPPING {% endcomment %}

<script>
// FIXED VARIANT MAPPING USING FUZZY MATCHING RESULTS

const isBundle = {% if product.metafields.bundleinfo.bundleproducts.value %}true{% else %}false{% endif %};

if (isBundle) {
  console.log("=== FIXED VARIANT MAPPING ===");
  
  // Build component delivery data using same pattern as delivery-info.liquid
  const componentDeliveryData = [
    {% for component in product.metafields.bundleinfo.bundleproducts.value %}
      {% assign full_product = all_products[component.handle] %}
      {
        "product": {
          "id": {{ full_product.id }},
          "title": "{{ full_product.title | escape }}",
          "handle": "{{ full_product.handle }}",
          "delivery_time": "{{ full_product.metafields.delivery.delivery_time | escape }}",
          "estimated_date": "{{ full_product.metafields.delivery.estimated_date | escape }}"
        },
        "variants": [
          {% assign valid_variants = false %}
          {% for variant in full_product.variants %}
            {% assign variant_delivery_date = variant.metafields.delivery.delivery_estimated_date %}
            {% unless variant_delivery_date %}
              {% assign variant_delivery_date = variant.metafields.delivery.delivery_estimated_date.value %}
            {% endunless %}
            {% if variant_delivery_date != blank %}
              {% if valid_variants %},{% endif %}
              {% assign valid_variants = true %}
              {
                "id": {{ variant.id }},
                "title": "{{ variant.title | escape }}",
                "delivery_estimated_date": "{{ variant_delivery_date | escape }}"
              }
            {% endif %}
          {% endfor %}
        ]
      }{% unless forloop.last %},{% endunless %}
    {% endfor %}
  ];
  
  // Bundle delivery data (levels 3 & 4)
  const bundleDeliveryData = {
    "bundleProduct": {
      "delivery_time": "{{ product.metafields.delivery.delivery_time | escape }}",
      "estimated_date": "{{ product.metafields.delivery.estimated_date | escape }}"
    },
    "bundleVariant": {
      {% assign bundle_variant_delivery_date = product.selected_or_first_available_variant.metafields.delivery.delivery_estimated_date %}
      {% unless bundle_variant_delivery_date %}
        {% assign bundle_variant_delivery_date = product.selected_or_first_available_variant.metafields.delivery.delivery_estimated_date.value %}
      {% endunless %}
      "delivery_estimated_date": "{{ bundle_variant_delivery_date | escape }}",
      "delivery_time": "{{ product.selected_or_first_available_variant.metafields.delivery.delivery_time | escape }}",
      "estimated_date": "{{ product.selected_or_first_available_variant.metafields.delivery.estimated_date | escape }}"
    }
  };
  
  const bundleOptions = {{ product.options | json }};
  const currentVariant = {{ product.selected_or_first_available_variant | json }};
  
  // Step 1: Do fuzzy matching to get correct component mapping
  function calculateMatchScore(optionName, productData) {
    const optionWords = optionName.toLowerCase().split(/[\s\/]+/);
    const titleWords = productData.product.title.toLowerCase().split(/[\s\/]+/);
    const handleWords = productData.product.handle.toLowerCase().split(/[\-\_]+/);
    
    let score = 0;
    
    // Check title matches
    optionWords.forEach(optionWord => {
      titleWords.forEach(titleWord => {
        if (optionWord === titleWord) score += 10; // Exact match
        if (titleWord.includes(optionWord) || optionWord.includes(titleWord)) score += 5; // Partial match
      });
    });
    
    // Check handle matches  
    optionWords.forEach(optionWord => {
      handleWords.forEach(handleWord => {
        if (optionWord === handleWord) score += 8; // Exact match
        if (handleWord.includes(optionWord) || optionWord.includes(handleWord)) score += 3; // Partial match
      });
    });
    
    return score;
  }
  
  // Step 2: Match each bundle option to the correct component using fuzzy matching
  const correctMatches = [];
  
  bundleOptions.forEach((optionName, index) => {
    let bestMatch = null;
    let bestScore = 0;
    let bestComponentIndex = -1;
    
    // Find best component match
    componentDeliveryData.forEach((component, componentIndex) => {
      const score = calculateMatchScore(optionName, component);
      if (score > bestScore) {
        bestScore = score;
        bestMatch = component;
        bestComponentIndex = componentIndex;
      }
    });
    
    // Get the user's selected value for this option
    const selectedValue = currentVariant.options[index];
    
    correctMatches.push({
      bundleOption: optionName,
      selectedValue: selectedValue,
      matchedComponent: bestMatch,
      componentIndex: bestComponentIndex,
      matchScore: bestScore
    });
  });
  
  console.log("Correct fuzzy matches:", correctMatches);
  
  // Step 3: Apply 4-level hierarchy using correct mapping
  correctMatches.forEach((match, index) => {
    console.log(`\n--- ${match.bundleOption}: ${match.matchedComponent.product.title} ---`);
    console.log("Selected value:", match.selectedValue);
    console.log("Product delivery_time:", match.matchedComponent.product.delivery_time);
    console.log("Product estimated_date:", match.matchedComponent.product.estimated_date);
    console.log("Available variants:", match.matchedComponent.variants);
    
    // Find matching variant using the correctly mapped selection
    const matchingVariant = match.matchedComponent.variants.find(variant => 
      variant.title === match.selectedValue || 
      variant.title.includes(match.selectedValue) || 
      match.selectedValue.includes(variant.title)
    );
    
    if (matchingVariant) {
      console.log("✅ Found matching variant:", matchingVariant.title);
      console.log("   Variant delivery date:", matchingVariant.delivery_estimated_date);
    } else {
      console.log("❌ No matching variant found");
    }
    
    // Apply COMPLETE 4-level hierarchy
    let finalDeliveryInfo = null;
    
    // Level 1: Component variant metafields (strongest)
    if (matchingVariant && matchingVariant.delivery_estimated_date) {
      finalDeliveryInfo = {
        type: 'estimated_date',
        value: matchingVariant.delivery_estimated_date,
        source: 'component_variant'
      };
    }
    // Level 2: Component product metafields
    else if (match.matchedComponent.product.delivery_time) {
      finalDeliveryInfo = {
        type: 'delivery_time', 
        value: match.matchedComponent.product.delivery_time,
        source: 'component_product'
      };
    }
    else if (match.matchedComponent.product.estimated_date) {
      finalDeliveryInfo = {
        type: 'estimated_date',
        value: match.matchedComponent.product.estimated_date,
        source: 'component_product'
      };
    }
    // Level 3: Bundle variant metafields
    else if (bundleDeliveryData.bundleVariant.delivery_estimated_date) {
      finalDeliveryInfo = {
        type: 'estimated_date',
        value: bundleDeliveryData.bundleVariant.delivery_estimated_date,
        source: 'bundle_variant'
      };
    }
    else if (bundleDeliveryData.bundleVariant.delivery_time) {
      finalDeliveryInfo = {
        type: 'delivery_time',
        value: bundleDeliveryData.bundleVariant.delivery_time,
        source: 'bundle_variant'
      };
    }
    else if (bundleDeliveryData.bundleVariant.estimated_date) {
      finalDeliveryInfo = {
        type: 'estimated_date',
        value: bundleDeliveryData.bundleVariant.estimated_date,
        source: 'bundle_variant'
      };
    }
    // Level 4: Bundle product metafields (weakest)
    else if (bundleDeliveryData.bundleProduct.delivery_time) {
      finalDeliveryInfo = {
        type: 'delivery_time',
        value: bundleDeliveryData.bundleProduct.delivery_time,
        source: 'bundle_product'
      };
    }
    else if (bundleDeliveryData.bundleProduct.estimated_date) {
      finalDeliveryInfo = {
        type: 'estimated_date',
        value: bundleDeliveryData.bundleProduct.estimated_date,
        source: 'bundle_product'
      };
    }
    else {
      finalDeliveryInfo = {
        type: 'none',
        value: 'No delivery info',
        source: 'none'
      };
    }
    
    console.log("🎯 FINAL DELIVERY INFO:", finalDeliveryInfo);
  });
  
  // Step 4: Build final combined delivery string
  const deliveryParts = correctMatches
    .map(match => {
      // Apply same hierarchy logic to get final value for each component
      const matchingVariant = match.matchedComponent.variants.find(variant => 
        variant.title === match.selectedValue || 
        variant.title.includes(match.selectedValue) || 
        match.selectedValue.includes(variant.title)
      );
      
      let deliveryValue = null;
      if (matchingVariant && matchingVariant.delivery_estimated_date) {
        deliveryValue = matchingVariant.delivery_estimated_date;
      } else if (match.matchedComponent.product.delivery_time) {
        deliveryValue = match.matchedComponent.product.delivery_time;
      } else if (match.matchedComponent.product.estimated_date) {
        deliveryValue = match.matchedComponent.product.estimated_date;
      }
      
      return deliveryValue ? `${match.matchedComponent.product.title}: ${deliveryValue}` : null;
    })
    .filter(part => part !== null);
  
  const combinedDeliveryString = deliveryParts.length > 0 ? 
    deliveryParts.join(', ') : 
    'No delivery information available';
    
  console.log("\n🎯 COMBINED DELIVERY STRING:", combinedDeliveryString);
  
} else {
  console.log("Not a bundle product");
}
</script> 